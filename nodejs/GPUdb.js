/*
 *  This file was autogenerated by the GPUdb schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */
/**
 * Creates a GPUdb API object for the specified URL using the given options.
 * Once created, all options are immutable; to use a different URL or change
 * options, create a new instance. (Creating a new instance does not
 * communicate with the server and should not cause performance concerns.)
 *
 * @class
 * @classdesc GPUdb API object that provides access to GPUdb server functions.
 * @param {String|String[]} url The URL of the GPUdb server (e.g.,
                   <code>http://hostname:9191</code>). May also be specified as
                   a list of urls; all urls in the list must be well formed.
 * @param {Object} [options] A set of configurable options for the GPUdb API.
 * @param {String} [options.username] The username to be used for authentication
 *                 to GPUdb. This username will be sent with every GPUdb request
 *                 made via the API along with the specified password and may be
 *                 used for authorization decisions by the server if it is so
 *                 configured. If neither username nor password is specified, no
 *                 authentication will be performed.
 * @param {String} [options.password] The password to be used for authentication
 *                 to GPUdb. This password will be sent with every GPUdb request
 *                 made via the API along with the specified username and may be
 *                 used for authorization decisions by the server if it is so
 *                 configured. If neither username nor password is specified, no
 *                 authentication will be performed.
 * @param {Number} [options.timeout] The timeout value, in milliseconds, after
 *                 which requests to GPUdb will be aborted. A timeout value of
 *                 zero is interpreted as an infinite timeout. Note that timeout
 *                 is not suppored for synchronous requests, which will not
 *                 return until a response is received and cannot be aborted.
 */
function GPUdb(url, options) {
    /**
     * The URLs of the GPUdb servers.
     *
     * @name GPUdb#parsedUrls
     * @type ConnectionToken[]
     * @readonly
     */
	var urls = (url instanceof Array) ? url : [url];
    var parsedUrls = [];

    urls.forEach(function(elem, index, array) {
        var parsed_url = require("url").parse(elem);
        if (parsed_url.protocol !== "http:" && parsed_url.protocol !== "https:") {
            throw new Error("Invalid URL specified.");
        }

        parsedUrls.push(new GPUdb.ConnectionToken(parsed_url));
    });

    var initialIndex = Math.floor(Math.random() * urls.length);
    Object.defineProperty(this, "urls", {
        enumerable: true,
        value: new GPUdb.RingList(parsedUrls, initialIndex)
    });

    /**
     * The URL of the current GPUdb server.
     *
     * @name GPUdb#url
     * @type String
     * @readonly
     */
    Object.defineProperty(this, "url", {
        get: function() {
            var token = this.urls.getCurrentItem();
            return token.protocol + '//' + token.host;
        },
		enumerable: true
	});

    /**
     * The protocol of the current GPUdb server address.
     *
     * @name GPUdb#protocol
     * @type String
     * @readonly
     */
    Object.defineProperty(this, "protocol", {
        get: function() { return this.urls.getCurrentItem().protocol; },
		enumerable: true
	});

    /**
     * The hostname of the current GPUdb server.
     *
     * @name GPUdb#hostname
     * @type String
     * @readonly
     */
    Object.defineProperty(this, "hostname", {
        get: function() { return this.urls.getCurrentItem().hostname; },
		enumerable: true
	});

    /**
     * The port of the current GPUdb server.
     *
     * @name GPUdb#port
     * @type String
     * @readonly
     */
    Object.defineProperty(this, "port", {
        get: function() { return this.urls.getCurrentItem().port; },
		enumerable: true
	});

    /**
     * The pathname of the current GPUdb server.
     *
     * @name GPUdb#pathname
     * @type String
     * @readonly
     */
    Object.defineProperty(this, "pathname", {
        get: function() { return this.urls.getCurrentItem().pathname; },
		enumerable: true
	});

    if (options !== undefined && options !== null) {
        /**
         * The username used for authentication to GPUdb. Will be an empty
         * string if none was provided to the {@link GPUdb GPUdb contructor}.
         *
         * @name GPUdb#username
         * @type String
         * @readonly
         */
        Object.defineProperty(this, "username", {
            enumerable: true,
            value: options.username !== undefined && options.username !== null ? options.username : ""
        });

        /**
         * The password used for authentication to GPUdb. Will be an empty
         * string if none was provided to the {@link GPUdb GPUdb constructor}.
         *
         * @name GPUdb#password
         * @type String
         * @readonly
         */
        Object.defineProperty(this, "password", {
            enumerable: true,
            value: options.password !== undefined && options.password !== null ? options.password : ""
        });

        /**
         * The timeout value, in milliseconds, after which requests to GPUdb
         * will be aborted. A timeout of zero is interpreted as an infinite
         * timeout. Will be zero if none was provided to the {@link GPUdb GPUdb
         * constructor}.
         *
         * @name GPUdb#timeout
         * @type Number
         * @readonly
         */
        Object.defineProperty(this, "timeout", {
            enumerable: true,
            value: options.timeout !== undefined && options.timeout !== null && options.timeout >= 0 ? options.timeout : 0
        });

        /**
         * Function to get request cookie
         *
         * @name GPUdb#getCookie
         * @type Function
         * @readonly
         */
        Object.defineProperty(this, "getCookie", {
            enumerable: true,
            value: options.getCookie
        });

        /**
         * Function to set responce cookie
         *
         * @name GPUdb#setCookie
         * @type Function
         * @readonly
         */
        Object.defineProperty(this, "setCookie", {
            enumerable: true,
            value: options.setCookie
        });
    } else {
        Object.defineProperty(this, "username", { enumerable: true, value: "" });
        Object.defineProperty(this, "password", { enumerable: true, value: "" });
        Object.defineProperty(this, "timeout", { enumerable: true, value: 0 });
    }

    if (this.username !== "" || this.password !== "") {
        Object.defineProperty(this, "authorization", {
            value: "Basic " + new Buffer(this.username + ":" + this.password).toString("base64")
        });
    } else {
        Object.defineProperty(this, "authorization", { value: "" });
    }
}

module.exports = GPUdb;

/**
 * Wrapper struct to tie together the parsed url fields.
 * @private
 */
GPUdb.ConnectionToken = function(parsed_url) {
    Object.defineProperty(this, "protocol", { value: parsed_url.protocol });
    Object.defineProperty(this, "hostname", { value: parsed_url.hostname });
    Object.defineProperty(this, "port", { value: parsed_url.port });
    Object.defineProperty(this, "pathname", { value: parsed_url.pathname.replace(/\/$/, "") });
    Object.defineProperty(this, "host", { value: parsed_url.host });
}

/**
 * Equality helper for comparing instances.
 * @private
 * @param {ConnectionToken} other The instance to compare to.
 */
GPUdb.ConnectionToken.prototype.equals = function(other) {
    return this.host === other.host;
}

/**
 * Submits an arbitrary request to GPUdb. The response will be returned via the
 * specified callback function, or via a promise if no callback function is
 * provided.
 *
 * @param {String} endpoint The endpoint to which to submit the request.
 * @param {Object} request The request object to submit.
 * @param {GPUdbCallback} [callback] The callback function.
 * @returns {Promise} A promise that will be fulfilled with the response object,
 *                    if no callback function is provided.
 */
GPUdb.prototype.submit_request = function(endpoint, request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise(function(resolve, reject) {
            self.submit_request(endpoint, request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve(response);
                }
            });
        });
    }

    var requestString = JSON.stringify(request);
    var initialConnToken = this.urls.getCurrentItem();
    var failureCount = 0;
    var timeout = this.timeout;
    var urls = this.urls;
    var authorization = this.authorization;
		var getCookie = this.getCookie;
		var setCookie = this.setCookie;

	/// Wraps the async callback with auto-retry logic
    var failureWrapperCB = function(err, data, url) {
        failureCount += 1;
        if (failureCount < urls.getSize()) {
            // If the current item has changed another request failed and
            // has already advanced the list. Retry using the new head.
            if ((url !== urls.getCurrentItem()) ||
                (!urls.getNextItem().equals(initialConnToken))) {
                sendRequest();
            }
        }
        else {
            callback(err, data);
        }
    };

	var sendRequest = function() {
        var connToken = urls.getCurrentItem();

        if (connToken.protocol === "http:") {
            var http = require("http");
        } else {
            var http = require("https");
        }

        var headers = { "Content-type": "application/json" };

        if (authorization !== "") {
            headers["Authorization"] = authorization;
        }

        if (getCookie && typeof getCookie === "function") {
            headers["Cookie"] = getCookie();
        }

        var got_error = false;

        var req = http.request({
                hostname: connToken.hostname,
                port: connToken.port,
                path: connToken.pathname + endpoint,
                method: "POST",
                headers: headers
            }, function(res) {
                var responseString = "";
                if (setCookie && typeof setCookie === "function") {
                    setCookie(res.headers["set-cookie"]);
                }

                res.on("data", function(chunk) {
                    responseString += chunk;
                });

                res.on("end", function() {
                    if (got_error) {
                        return;
                    }

                    try {
                        var response = JSON.parse(responseString);
                    } catch (e) {
                        callback(new Error("Unable to parse response: " + e), null);
                        return;
                    }

                    if (response.status === "OK") {
                        try {
                            var data = JSON.parse(response.data_str.replace(/\\U/g,"\\u"));
                        } catch (e) {
                            callback(new Error("Unable to parse response: " + e), null);
                            return;
                        }

                        if ("x-request-time-secs" in res.headers) {
                            data.request_time_secs = Number(res.headers["x-request-time-secs"]);
                        }

                        callback(null, data);
                    } else {
                        callback(new Error(response.message), null);
                    }
                });

                res.on("error", function(err) {
                    got_error = true;
                    failureWrapperCB(new Error(), null, connToken);
                });
            });

        req.on("error", function(err) {
            got_error = true;
            failureWrapperCB(new Error(), null, connToken);
        });

        req.setTimeout(timeout, function() {
            got_error = true;
            failureWrapperCB(new Error("Request timed out"), null, connToken);
        });

        req.write(requestString);
        req.end();
    };

    sendRequest();
};

/**
 * Request a WMS (Web Map Service) rasterized image. The image will be returned
 * as a Node.js Buffer object via the specified callback function, or via a
 * promise if no callback function is provided.
 *
 * @param {Object} request Object containing WMS parameters.
 * @param {GPUdbCallback} [callback] The callback function.
 * @returns {Promise} A promise that will be fulfilled with the image, if no
 *                    callback function is provided.
 */
GPUdb.prototype.wms_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise(function(resolve, reject) {
            self.wms_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve(response);
                }
            });
        });
    }

    var queryString = require("querystring").stringify(request);
    var initialConnToken = this.urls.getCurrentItem();
    var failureCount = 0;
    var timeout = this.timeout;
    var urls = this.urls;
    var authorization = this.authorization;
		var getCookie = this.getCookie;
		var setCookie = this.setCookie;

	/// Wraps the async callback with auto-retry logic
    var failureWrapperCB = function(err, data, url) {
        failureCount += 1;
        if (failureCount < urls.getSize()) {
            // If the current item has changed another request failed and
            // has already advanced the list. Retry using the new head.
            if ((url !== urls.getCurrentItem()) ||
                (!urls.getNextItem().equals(initialConnToken))) {
                sendRequest();
            }
        }
        else {
            callback(err, data);
        }
    };

    var sendRequest = function() {
        var connToken = urls.getCurrentItem();

        if (connToken.protocol === "http:") {
            var http = require("http");
        } else {
            var http = require("https");
        }

        var headers = { "Content-type": "application/json" };

        if (authorization !== "") {
            headers["Authorization"] = authorization;
        }

        if (getCookie && typeof getCookie === "function") {
            headers["Cookie"] = getCookie();
        }

        var got_error = false;

        var req = http.request({
            hostname: connToken.hostname,
            port: connToken.port,
            path: connToken.pathname + "/wms?" + queryString,
            headers: headers,
        }, function(res) {
            var data = [];
            if (setCookie && typeof setCookie === "function") {
                setCookie(res.headers["set-cookie"]);
            }

            res.on("data", function(chunk) {
                data.push(chunk);
            });

            res.on("end", function() {
                if (got_error) {
                    return;
                }

                var dataBuffer = Buffer.concat(data);
                if ("x-request-time-secs" in res.headers) {
                    dataBuffer.request_time_secs = Number(res.headers["x-request-time-secs"]);
                }

                callback(null, dataBuffer);
            });

            res.on("error", function(err) {
                got_error = true;
                failureWrapperCB(err, null, connToken);
            });
        });

        req.on("error", function(err) {
            got_error = true;
            failureWrapperCB(err, null, connToken);
        });

        req.setTimeout(timeout, function() {
            got_error = true;
            failureWrapperCB(new Error("Request timed out"), null, connToken);
        });

        req.end();
    };

    sendRequest();
}
/**
 * A list with only one exposed element at a time, but with N stored elements.
 * The elements of the list are immutable.
 * @private
 */
GPUdb.RingList = function(items, initialIndex) {
    Object.defineProperty(this, "items", { enumerable: true, value: items });
    Object.defineProperty(this, "index", {
        enumerable: true,
        value: (initialIndex !== undefined && initialIndex !== null &&
                initialIndex >= 0 ? initialIndex : 0),
        writable: true
    });
}

/**
 * @private
 * @return The currently exposed item
 */
GPUdb.RingList.prototype.getCurrentItem = function() {
    return this.items[this.index];
}

/**
 * Increments the current item index, wrapping if necessary.
 * @private
 * @return The currently exposed item
 */
GPUdb.RingList.prototype.getNextItem = function() {
    this.index += 1;
    if (this.index >= this.items.length) {
        this.index = 0;
    }

    return this.items[this.index];
}

/**
 * @private
 *
 * @return The number of elements available within the list.
 */
GPUdb.RingList.prototype.getSize = function() {
    return this.items.length;
}

/**
 * Callback function used for asynchronous GPUdb calls.
 *
 * @callback GPUdbCallback
 * @param {Error} err Object containing error information returned from the
 *                call. Will be null if no error occurred.
 * @param {Object} response Object containing any data returned from the call.
 *                 Will be null if an error occurred.
 */
/**
 * Creates a Type object containing metadata about a GPUdb type.
 *
 * @class
 * @classdesc Metadata about a GPUdb type.
 * @param {String} label A user-defined description string which can be used to
 *                 differentiate between data with otherwise identical schemas.
 * @param {...GPUdb.Type.Column} columns The list of columns that the type
 *                               comprises.
 */
GPUdb.Type = function(label, columns) {
    /**
     * A user-defined description string which can be used to differentiate
     * between data with otherwise identical schemas.
     *
     * @name GPUdb.Type#label
     * @type String
     */
    this.label = label;

    /**
     * The list of columns that the type comprises.
     *
     * @name GPUdb.Type#columns
     * @type GPUdb.Type.Column[]
     */
    if (Array.isArray(columns)) {
        this.columns = columns;
    } else {
        this.columns = [];

        for (var i = 1; i < arguments.length; i++) {
            this.columns.push(arguments[i]);
        }
    }
};

/**
 * Creates a Column object containing metadata about a column that is part of a
 * GPUdb type.
 *
 * @class
 * @classdesc Metadata about a column that is part of a GPUdb type.
 * @param {String} name The name of the column.
 * @param {String} type The data type of the column.
 * @param {...String} [properties] The list of properties that apply to the
                      column; defaults to none.
 */
GPUdb.Type.Column = function(name, type, properties) {
    /**
     * The name of the column.
     *
     * @name GPUdb.Type.Column#name
     * @type String
     */
    this.name = name;

    /**
     * The data type of the column.
     *
     * @name GPUdb.Type.Column#type
     * @type String
     */
    this.type = type;

    /**
     * The list of properties that apply to the column.
     *
     * @name GPUdb.Type.Column#properties
     * @type String[]
     */
    if (properties !== undefined && properties !== null) {
        if (Array.isArray(properties)) {
            this.properties = properties;
        } else {
            this.properties = [];

            for (var i = 2; i < arguments.length; i++) {
                this.properties.push(arguments[i]);
            }
        }
    } else {
        this.properties = [];
    }
};

/**
 * Gets whether the column is nullable.
 *
 * @returns {boolean} Whether the column is nullable.
 */
GPUdb.Type.Column.prototype.is_nullable = function() {
    return this.properties.indexOf("nullable") > -1;
};

/**
 * Creates a Type object using data returned from the GPUdb show_table or
 * show_types endpoints.
 *
 * @param {String} label A user-defined description string which can be used to
 *                 differentiate between data with otherwise identical schemas.
 * @param {String|Object} type_schema The Avro record schema for the type.
 * @param {Object.<String, String[]>} properties A map of column names to
 *                                    lists of properties that apply to those
 *                                    columns.
 * @returns {GPUdb.Type} The Type object.
 */
GPUdb.Type.from_type_info = function(label, type_schema, properties) {
    if (typeof type_schema === "string" || type_schema instanceof String) {
        type_schema = JSON.parse(type_schema);
    }

    var columns = [];

    for (var i = 0; i < type_schema.fields.length; i++) {
        var field = type_schema.fields[i];
        var type = field.type;

        if (Array.isArray(type)) {
            for (var j = 0; j < type.length; j++) {
                if (type[j] !== "null") {
                    type = type[j];
                    break;
                }
            }
        }

        columns.push(new GPUdb.Type.Column(field.name, type, properties[field.name]));
    }

    return new GPUdb.Type(label, columns);
};

/**
 * Generates an Avro record schema based on the metadata in the Type object.
 *
 * @returns {Object} The Avro record schema.
 */
GPUdb.Type.prototype.generate_schema = function() {
    var schema = {
        type: "record",
        name: "type_name",
        fields: []
    };

    for (var i = 0; i < this.columns.length; i++) {
        var column = this.columns[i];

        schema.fields.push({
            name: column.name,
            type: column.is_nullable() ? [ column.type, "null" ] : column.type
        });
    }

    return schema;
};

/**
 * The version number of the GPUdb JavaScript API.
 *
 * @name GPUdb#api_version
 * @type String
 * @readonly
 * @static
 */
Object.defineProperty(GPUdb, "api_version", { enumerable: true, value: "6.0.1" });

/**
 * Constant used with certain requests to indicate that the maximum allowed
 * number of results should be returned.
 *
 * @name GPUdb#END_OF_SET
 * @type Number
 * @readonly
 * @static
 */
Object.defineProperty(GPUdb, "END_OF_SET", { value: -9999 });

/**
 * Decodes a JSON string, or array of JSON strings, returned from GPUdb into
 * JSON object(s).
 *
 * @param {String | String[]} o The JSON string(s) to decode.
 * @returns {Object | Object[]} The decoded JSON object(s).
 */
GPUdb.decode = function(o) {
    if (Array.isArray(o)) {
        var result = [];

        for (var i = 0; i < o.length; i++) {
            result.push(GPUdb.decode(o[i]));
        }

        return result;
    } else {
        return JSON.parse(o);
    }
};

/**
 * Encodes a JSON object, or array of JSON objects, into JSON string(s) to be
 * passed to GPUdb.
 *
 * @param {Object | Object[]} o The JSON object(s) to encode.
 * @returns {String | String[]} The encoded JSON string(s).
 */
GPUdb.encode = function(o) {
    if (Array.isArray(o)) {
        var result = [];

        for (var i = 0; i < o.length; i++) {
            result.push(GPUdb.encode(o[i]));
        }

        return result;
    } else {
        return JSON.stringify(o);
    }
};
/**
 * Creates a Type object containing metadata about the type stored in the
 * specified table in GPUdb and returns it via the specified callback function,
 * or via a promise if no callback function is provided.
 *
 * @param {GPUdb} gpudb GPUdb API object.
 * @param {String} table_name The table from which to obtain type metadata.
 * @param {GPUdbCallback} [callback] The callback function.
 * @returns {Promise} A promise that will be fulfilled with the type object, if
 *                    no callback function is provided.
 */
GPUdb.Type.from_table = function(gpudb, table_name, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise(function(resolve, reject) {
            self.from_table(gpudb, table_name, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve(response);
                }
            });
        });
    }

    var process_response = function(response, callback) {
        if (response.type_ids.length === 0) {
            callback(new Error("Table " + table_name + " does not exist."), null);
        }

        if (response.type_ids.length > 1) {
            var type_id = response.type_ids[0];

            for (var i = 1; i < response.type_ids.length; i++) {
                if (response.type_ids[i] !== type_id) {
                    callback(new Error("Table " + table_name + " is not homogeneous."), null);
                }
            }
        }

        callback(null, GPUdb.Type.from_type_info(response.type_labels[0], response.type_schemas[0], response.properties[0]));
    };

    gpudb.show_table(table_name, {}, function(err, data) {
        if (err === null) {
            process_response(data, callback);
        } else {
            callback(err, null);
        }
    });
};

/**
 * Creates a Type object containing metadata about the specified type in GPUdb
 * and returns it via the specified callback function, or via a promise if no
 * callback function is provided.
 *
 * @param {GPUdb} gpudb GPUdb API object.
 * @param {String} type_id The type for which to obtain metadata.
 * @param {GPUdbCallback} [callback] The callback function.
 * @returns {Promise} A promise that will be fulfilled with the type object, if
 *                    no callback function is provided.
 */
GPUdb.Type.from_type = function(gpudb, type_id, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise(function(resolve, reject) {
            self.from_type(gpudb, type_id, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve(response);
                }
            });
        });
    }

    var process_response = function(response, callback) {
        if (response.type_ids.length === 0) {
            callback(Error("Type " + type_id + " does not exist."), null);
        }

        callback(null, GPUdb.Type.from_type_info(response.labels[0], response.type_schemas[0], response.properties[0]));
    };

    gpudb.show_types(type_id, "", {}, function(err, data) {
        if (err === null) {
            process_response(data, callback);
        } else {
            callback(err, null);
        }
    });
};

/**
 * Creates a new type in GPUdb based on the metadata in the Type object and
 * returns the GPUdb type ID via the specified callback function, or via a
 * promise if no callback function is provided, for use in subsequent
 * operations.
 *
 * @param {GPUdb} gpudb GPUdb API object.
 * @param {GPUdbCallback} [callback] The callback function.
 * @returns {Promise} A promise that will be fulfilled with the type ID, if no
 *                    callback function is provided.
 */
GPUdb.Type.prototype.create = function(gpudb, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise(function(resolve, reject) {
            self.create(gpudb, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve(response);
                }
            });
        });
    }

    var properties = {};

    for (var i = 0; i < this.columns.length; i++) {
        var column = this.columns[i];

        if (column.properties.length > 0) {
            properties[column.name] = column.properties;
        }
    }

    gpudb.create_type(JSON.stringify(this.generate_schema()), this.label, properties, {}, function(err, data) {
        if (err === null) {
            callback(null, data.type_id);
        } else {
            callback(err, null);
        }
    });
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.admin_delete_node_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_delete_node_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        rank: request.rank,
        authorization: request.authorization,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/delete/node", actual_request, callback);
};

/**
 *
 * @param {Number} rank
 * @param {String} authorization
 * @param {Object} options
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.admin_delete_node = function(rank, authorization, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_delete_node(rank, authorization, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        rank: rank,
        authorization: authorization,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/delete/node", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.admin_get_shard_assignments_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_get_shard_assignments_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/getshardassignments", actual_request, callback);
};

/**
 *
 * @param {Object} options
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.admin_get_shard_assignments = function(options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_get_shard_assignments(options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/getshardassignments", actual_request, callback);
};

/**
 * Take the system offline. When the system is offline, no user operations can
 * be performed with the exception of a system shutdown.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_offline_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_offline_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        offline: request.offline,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/offline", actual_request, callback);
};

/**
 * Take the system offline. When the system is offline, no user operations can
 * be performed with the exception of a system shutdown.
 *
 * @param {Boolean} offline  Set to true if desired state is offline. Values:
 *                           true, false.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_offline = function(offline, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_offline(offline, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        offline: offline,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/offline", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.admin_rebalance_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_rebalance_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: request.table_names,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/rebalance", actual_request, callback);
};

/**
 *
 * @param {String[]} table_names
 * @param {Object} options
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.admin_rebalance = function(table_names, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_rebalance(table_names, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: table_names,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/rebalance", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.admin_set_shard_assignments_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_set_shard_assignments_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        version: request.version,
        partial_reassignment: request.partial_reassignment,
        shard_assignments_rank: request.shard_assignments_rank,
        shard_assignments_tom: request.shard_assignments_tom,
        assignment_index: request.assignment_index,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/setshardassignments", actual_request, callback);
};

/**
 *
 * @param {Number} version
 * @param {Boolean} partial_reassignment
 * @param {Number[]} shard_assignments_rank
 * @param {Number[]} shard_assignments_tom
 * @param {Number[]} assignment_index
 * @param {Object} options
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.admin_set_shard_assignments = function(version, partial_reassignment, shard_assignments_rank, shard_assignments_tom, assignment_index, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_set_shard_assignments(version, partial_reassignment, shard_assignments_rank, shard_assignments_tom, assignment_index, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        version: version,
        partial_reassignment: partial_reassignment,
        shard_assignments_rank: shard_assignments_rank,
        shard_assignments_tom: shard_assignments_tom,
        assignment_index: assignment_index,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/setshardassignments", actual_request, callback);
};

/**
 * Exits the database server application.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_shutdown_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_shutdown_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        exit_type: request.exit_type,
        authorization: request.authorization,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/shutdown", actual_request, callback);
};

/**
 * Exits the database server application.
 *
 * @param {String} exit_type  Reserved for future use. User can pass an empty
 *                            string.
 * @param {String} authorization  No longer used. User can pass an empty
 *                                string.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_shutdown = function(exit_type, authorization, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_shutdown(exit_type, authorization, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        exit_type: exit_type,
        authorization: authorization,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/shutdown", actual_request, callback);
};

/**
 * Verify database is in a consistent state.  When inconsistencies or errors
 * are found, the verified_ok flag in the response is set to false and the list
 * of errors found is provided in the error_list.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_verify_db_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_verify_db_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/verifydb", actual_request, callback);
};

/**
 * Verify database is in a consistent state.  When inconsistencies or errors
 * are found, the verified_ok flag in the response is set to false and the list
 * of errors found is provided in the error_list.
 *
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_verify_db = function(options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_verify_db(options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/verifydb", actual_request, callback);
};

/**
 * Calculates and returns the convex hull for the values in a table specified
 * by <code>table_name</code>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_convex_hull_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_convex_hull_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        x_column_name: request.x_column_name,
        y_column_name: request.y_column_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/aggregate/convexhull", actual_request, callback);
};

/**
 * Calculates and returns the convex hull for the values in a table specified
 * by <code>table_name</code>.
 *
 * @param {String} table_name  Name of Table on which the operation will be
 *                             performed. Must be an existing table.  It can
 *                             not be a collection.
 * @param {String} x_column_name  Name of the column containing the x
 *                                coordinates of the points for the operation
 *                                being performed.
 * @param {String} y_column_name  Name of the column containing the y
 *                                coordinates of the points for the operation
 *                                being performed.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_convex_hull = function(table_name, x_column_name, y_column_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_convex_hull(table_name, x_column_name, y_column_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        x_column_name: x_column_name,
        y_column_name: y_column_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/aggregate/convexhull", actual_request, callback);
};

/**
 * Calculates unique combinations (groups) of values for the given columns in a
 * given table/view/collection and computes aggregates on each unique
 * combination. This is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * Any column(s) can be grouped on, but only non-string (i.e. numeric) columns
 * may be used for computing aggregates. The results can be paged via the
 * <code>offset</code> and <code>limit</code> parameters. For example, to get
 * 10 groups with the largest counts the inputs would be: limit=10,
 * options={"sort_order":"descending", "sort_by":"value"}. <code>options</code>
 * can be used to customize behavior of this call e.g. filtering or sorting the
 * results. To group by 'x' and 'y' and compute the number of objects within
 * each group, use column_names=['x','y','count(*)'].  To also compute the sum
 * of 'z' over each group, use column_names=['x','y','count(*)','sum(z)'].
 * Available aggregation functions are: 'count(*)', 'sum', 'min', 'max', 'avg',
 * 'mean', 'stddev', 'stddev_pop', 'stddev_samp', 'var', 'var_pop', 'var_samp',
 * 'arg_min', 'arg_max' and 'count_distinct'. The response is returned as a
 * dynamic schema. For details see: <a
 * href="../../concepts/dynamic_schemas.html" target="_top">dynamic schemas
 * documentation</a>. If the <code>result_table</code> option is provided then
 * the results are stored in a table with the name given in the option and the
 * results are not returned in the response.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_group_by_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_group_by_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        column_names: request.column_names,
        offset: request.offset,
        limit: (request.limit !== undefined && request.limit !== null) ? request.limit : 1000,
        encoding: (request.encoding !== undefined && request.encoding !== null) ? request.encoding : "json",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/aggregate/groupby", actual_request, function(err, data) {
        if (err === null) {
            data.data = GPUdb.decode(data.json_encoded_response);
            delete data.json_encoded_response;
        }

        callback(err, data);
    });
};

/**
 * Calculates unique combinations (groups) of values for the given columns in a
 * given table/view/collection and computes aggregates on each unique
 * combination. This is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * Any column(s) can be grouped on, but only non-string (i.e. numeric) columns
 * may be used for computing aggregates. The results can be paged via the
 * <code>offset</code> and <code>limit</code> parameters. For example, to get
 * 10 groups with the largest counts the inputs would be: limit=10,
 * options={"sort_order":"descending", "sort_by":"value"}. <code>options</code>
 * can be used to customize behavior of this call e.g. filtering or sorting the
 * results. To group by 'x' and 'y' and compute the number of objects within
 * each group, use column_names=['x','y','count(*)'].  To also compute the sum
 * of 'z' over each group, use column_names=['x','y','count(*)','sum(z)'].
 * Available aggregation functions are: 'count(*)', 'sum', 'min', 'max', 'avg',
 * 'mean', 'stddev', 'stddev_pop', 'stddev_samp', 'var', 'var_pop', 'var_samp',
 * 'arg_min', 'arg_max' and 'count_distinct'. The response is returned as a
 * dynamic schema. For details see: <a
 * href="../../concepts/dynamic_schemas.html" target="_top">dynamic schemas
 * documentation</a>. If the <code>result_table</code> option is provided then
 * the results are stored in a table with the name given in the option and the
 * results are not returned in the response.
 *
 * @param {String} table_name  Name of the table on which the operation will be
 *                             performed. Must be an existing
 *                             table/view/collection.
 * @param {String[]} column_names  List of one or more column names,
 *                                 expressions, and aggregate expressions. Must
 *                                 include at least one 'grouping' column or
 *                                 expression.  If no aggregate is included,
 *                                 count(*) will be computed as a default.
 * @param {Number} offset  A positive integer indicating the number of initial
 *                         results to skip (this can be useful for paging
 *                         through the results).
 * @param {Number} limit  A positive integer indicating the maximum number of
 *                        results to be returned Or END_OF_SET (-9999) to
 *                        indicate that the max number of results should be
 *                        returned.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> collection_name: Name of a collection
 *                          which is to contain the table specified in
 *                          <code>result_table</code>, otherwise the table will
 *                          be a top-level table. If the collection does not
 *                          allow duplicate types and it contains a table of
 *                          the same type as the given one, then this table
 *                          creation request will fail. Additionally this
 *                          option is invalid if <code>table_name</code> is a
 *                          collection.
 *                                  <li> expression: Filter expression to apply
 *                          to the table prior to computing the aggregate group
 *                          by.
 *                                  <li> having: Filter expression to apply to
 *                          the aggregated results.
 *                                  <li> sort_order: String indicating how the
 *                          returned values should be sorted - ascending or
 *                          descending. Values: ascending, descending.
 *                                  <li> sort_by: String determining how the
 *                          results are sorted. Values: key, value.
 *                                  <li> result_table: The name of the table
 *                          used to store the results. Has the same naming
 *                          restrictions as <a
 *                          href="../../concepts/tables.html"
 *                          target="_top">tables</a>. Column names (group-by
 *                          and aggregate fields) need to be given aliases e.g.
 *                          ["FChar256 as fchar256", "sum(FDouble) as sfd"].
 *                          If present, no results are returned in the
 *                          response.  This option is not available if one of
 *                          the grouping attributes is an unrestricted string
 *                          (i.e.; not charN) type.
 *                                  <li> ttl: Sets the TTL of the table
 *                          specified in <code>result_table</code>. The value
 *                          must be the desired TTL in minutes.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_group_by = function(table_name, column_names, offset, limit, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_group_by(table_name, column_names, offset, limit, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        column_names: column_names,
        offset: offset,
        limit: (limit !== undefined && limit !== null) ? limit : 1000,
        encoding: "json",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/aggregate/groupby", actual_request, function(err, data) {
        if (err === null) {
            data.data = GPUdb.decode(data.json_encoded_response);
            delete data.json_encoded_response;
        }

        callback(err, data);
    });
};

/**
 * Performs a histogram calculation given a table, a column, and an interval
 * function. The <code>interval</code> is used to produce bins of that size and
 * the result, computed over the records falling within each bin, is returned.
 * For each bin, the start value is inclusive, but the end value is
 * exclusive--except for the very last bin for which the end value is also
 * inclusive.  The value returned for each bin is the number of records in it,
 * except when a column name is provided as a *value_column* in
 * <code>options</code>.  In this latter case the sum of the values
 * corresponding to the *value_column* is used as the result instead.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_histogram_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_histogram_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        column_name: request.column_name,
        start: request.start,
        end: request.end,
        interval: request.interval,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/aggregate/histogram", actual_request, callback);
};

/**
 * Performs a histogram calculation given a table, a column, and an interval
 * function. The <code>interval</code> is used to produce bins of that size and
 * the result, computed over the records falling within each bin, is returned.
 * For each bin, the start value is inclusive, but the end value is
 * exclusive--except for the very last bin for which the end value is also
 * inclusive.  The value returned for each bin is the number of records in it,
 * except when a column name is provided as a *value_column* in
 * <code>options</code>.  In this latter case the sum of the values
 * corresponding to the *value_column* is used as the result instead.
 *
 * @param {String} table_name  Name of the table on which the operation will be
 *                             performed. Must be an existing table or
 *                             collection.
 * @param {String} column_name  Name of a column or an expression of one or
 *                              more column names over which the histogram will
 *                              be calculated.
 * @param {Number} start  Lower end value of the histogram interval, inclusive.
 * @param {Number} end  Upper end value of the histogram interval, inclusive.
 * @param {Number} interval  The size of each bin within the start and end
 *                           parameters.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> value_column: The name of the column
 *                          to use when calculating the bin values (values are
 *                          summed).  The column must be a numerical type (int,
 *                          double, long, float).
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_histogram = function(table_name, column_name, start, end, interval, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_histogram(table_name, column_name, start, end, interval, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        column_name: column_name,
        start: start,
        end: end,
        interval: interval,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/aggregate/histogram", actual_request, callback);
};

/**
 * This endpoint runs the k-means algorithm - a heuristic algorithm that
 * attempts to do k-means clustering.  An ideal k-means clustering algorithm
 * selects k points such that the sum of the mean squared distances of each
 * member of the set to the nearest of the k points is minimized.  The k-means
 * algorithm however does not necessarily produce such an ideal cluster.   It
 * begins with a randomly selected set of k points and then refines the
 * location of the points iteratively and settles to a local minimum.  Various
 * parameters and options are provided to control the heuristic search.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_k_means_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_k_means_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        column_names: request.column_names,
        k: request.k,
        tolerance: request.tolerance,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/aggregate/kmeans", actual_request, callback);
};

/**
 * This endpoint runs the k-means algorithm - a heuristic algorithm that
 * attempts to do k-means clustering.  An ideal k-means clustering algorithm
 * selects k points such that the sum of the mean squared distances of each
 * member of the set to the nearest of the k points is minimized.  The k-means
 * algorithm however does not necessarily produce such an ideal cluster.   It
 * begins with a randomly selected set of k points and then refines the
 * location of the points iteratively and settles to a local minimum.  Various
 * parameters and options are provided to control the heuristic search.
 *
 * @param {String} table_name  Name of the table on which the operation will be
 *                             performed. Must be an existing table or
 *                             collection.
 * @param {String[]} column_names  List of column names on which the operation
 *                                 would be performed. If n columns are
 *                                 provided then each of the k result points
 *                                 will have n dimensions corresponding to the
 *                                 n columns.
 * @param {Number} k  The number of mean points to be determined by the
 *                    algorithm.
 * @param {Number} tolerance  Stop iterating when the distances between
 *                            successive points is less than the given
 *                            tolerance.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> whiten: When set to 1 each of the
 *                          columns is first normalized by its stdv - default
 *                          is not to whiten.
 *                                  <li> max_iters: Number of times to try to
 *                          hit the tolerance limit before giving up - default
 *                          is 10.
 *                                  <li> num_tries: Number of times to run the
 *                          k-means algorithm with a different randomly
 *                          selected starting points - helps avoid local
 *                          minimum. Default is 1.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_k_means = function(table_name, column_names, k, tolerance, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_k_means(table_name, column_names, k, tolerance, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        column_names: column_names,
        k: k,
        tolerance: tolerance,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/aggregate/kmeans", actual_request, callback);
};

/**
 * Calculates and returns the minimum and maximum values of a particular column
 * in a table.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_min_max_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_min_max_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        column_name: request.column_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/aggregate/minmax", actual_request, callback);
};

/**
 * Calculates and returns the minimum and maximum values of a particular column
 * in a table.
 *
 * @param {String} table_name  Name of the table on which the operation will be
 *                             performed. Must be an existing table.
 * @param {String} column_name  Name of a column or an expression of one or
 *                              more column on which the min-max will be
 *                              calculated.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_min_max = function(table_name, column_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_min_max(table_name, column_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        column_name: column_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/aggregate/minmax", actual_request, callback);
};

/**
 * Calculates the requested statistics of a given column in a given table.
 * <p>
 * The available statistics are count (number of total objects), mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max,
 * weighted_average, cardinality (unique count), estimated cardinality,
 * percentile and percentile_rank.
 * <p>
 * Estimated cardinality is calculated by using the hyperloglog approximation
 * technique.
 * <p>
 * Percentiles and percentile_ranks are approximate and are calculated using
 * the t-digest algorithm. They must include the desired
 * percentile/percentile_rank. To compute multiple percentiles each value must
 * be specified separately (i.e.
 * 'percentile(75.0),percentile(99.0),percentile_rank(1234.56),percentile_rank(-5)').
 * <p>
 * The weighted average statistic requires a weight_attribute to be specified
 * in <code>options</code>. The weighted average is then defined as the sum of
 * the products of <code>column_name</code> times the weight attribute divided
 * by the sum of the weight attribute.
 * <p>
 * The response includes a list of the statistics requested along with the
 * count of the number of items in the given set.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_statistics_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_statistics_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        column_name: request.column_name,
        stats: request.stats,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/aggregate/statistics", actual_request, callback);
};

/**
 * Calculates the requested statistics of a given column in a given table.
 * <p>
 * The available statistics are count (number of total objects), mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max,
 * weighted_average, cardinality (unique count), estimated cardinality,
 * percentile and percentile_rank.
 * <p>
 * Estimated cardinality is calculated by using the hyperloglog approximation
 * technique.
 * <p>
 * Percentiles and percentile_ranks are approximate and are calculated using
 * the t-digest algorithm. They must include the desired
 * percentile/percentile_rank. To compute multiple percentiles each value must
 * be specified separately (i.e.
 * 'percentile(75.0),percentile(99.0),percentile_rank(1234.56),percentile_rank(-5)').
 * <p>
 * The weighted average statistic requires a weight_attribute to be specified
 * in <code>options</code>. The weighted average is then defined as the sum of
 * the products of <code>column_name</code> times the weight attribute divided
 * by the sum of the weight attribute.
 * <p>
 * The response includes a list of the statistics requested along with the
 * count of the number of items in the given set.
 *
 * @param {String} table_name  Name of the table on which the statistics
 *                             operation will be performed.
 * @param {String} column_name  Name of the column for which the statistics are
 *                              to be calculated.
 * @param {String} stats  Comma separated list of the statistics to calculate,
 *                        e.g. "sum,mean". Values: count, mean, stdv, variance,
 *                        skew, kurtosis, sum, min, max, weighted_average,
 *                        cardinality, estimated_cardinality, percentile,
 *                        percentile_rank.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> additional_column_names: A list of
 *                          comma separated column names over which statistics
 *                          can be accumulated along with the primary column.
 *                                  <li> weight_column_name: Name of column
 *                          used as weighting attribute for the weighted
 *                          average statistic.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_statistics = function(table_name, column_name, stats, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_statistics(table_name, column_name, stats, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        column_name: column_name,
        stats: stats,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/aggregate/statistics", actual_request, callback);
};

/**
 * Divides the given set into bins and calculates statistics of the values of a
 * value-column in each bin.  The bins are based on the values of a given
 * binning-column.  The statistics that may be requested are mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max, first, last
 * and weighted average. In addition to the requested statistics the count of
 * total samples in each bin is returned. This counts vector is just the
 * histogram of the column used to divide the set members into bins. The
 * weighted average statistic requires a weight_column to be specified in
 * <code>options</code>. The weighted average is then defined as the sum of the
 * products of the value column times the weight column divided by the sum of
 * the weight column.
 * <p>
 * There are two methods for binning the set members. In the first, which can
 * be used for numeric valued binning-columns, a min, max and interval are
 * specified. The number of bins, nbins, is the integer upper bound of
 * (max-min)/interval. Values that fall in the range
 * [min+n\*interval,min+(n+1)\*interval) are placed in the nth bin where n
 * ranges from 0..nbin-2. The final bin is [min+(nbin-1)\*interval,max]. In the
 * second method, <code>options</code> bin_values specifies a list of binning
 * column values. Binning-columns whose value matches the nth member of the
 * bin_values list are placed in the nth bin. When a list is provided the
 * binning-column must be of type string or int.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_statistics_by_range_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_statistics_by_range_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        select_expression: (request.select_expression !== undefined && request.select_expression !== null) ? request.select_expression : "",
        column_name: request.column_name,
        value_column_name: request.value_column_name,
        stats: request.stats,
        start: request.start,
        end: request.end,
        interval: request.interval,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/aggregate/statistics/byrange", actual_request, callback);
};

/**
 * Divides the given set into bins and calculates statistics of the values of a
 * value-column in each bin.  The bins are based on the values of a given
 * binning-column.  The statistics that may be requested are mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max, first, last
 * and weighted average. In addition to the requested statistics the count of
 * total samples in each bin is returned. This counts vector is just the
 * histogram of the column used to divide the set members into bins. The
 * weighted average statistic requires a weight_column to be specified in
 * <code>options</code>. The weighted average is then defined as the sum of the
 * products of the value column times the weight column divided by the sum of
 * the weight column.
 * <p>
 * There are two methods for binning the set members. In the first, which can
 * be used for numeric valued binning-columns, a min, max and interval are
 * specified. The number of bins, nbins, is the integer upper bound of
 * (max-min)/interval. Values that fall in the range
 * [min+n\*interval,min+(n+1)\*interval) are placed in the nth bin where n
 * ranges from 0..nbin-2. The final bin is [min+(nbin-1)\*interval,max]. In the
 * second method, <code>options</code> bin_values specifies a list of binning
 * column values. Binning-columns whose value matches the nth member of the
 * bin_values list are placed in the nth bin. When a list is provided the
 * binning-column must be of type string or int.
 *
 * @param {String} table_name  Name of the table on which the ranged-statistics
 *                             operation will be performed.
 * @param {String} select_expression  For a non-empty expression statistics are
 *                                    calculated for those records for which
 *                                    the expression is true.
 * @param {String} column_name  Name of the binning-column used to divide the
 *                              set samples into bins.
 * @param {String} value_column_name  Name of the value-column for which
 *                                    statistics are to be computed.
 * @param {String} stats  A string of comma separated list of the statistics to
 *                        calculate, e.g. 'sum,mean'. Available statistics:
 *                        mean, stdv (standard deviation), variance, skew,
 *                        kurtosis, sum.
 * @param {Number} start  The lower bound of the binning-column.
 * @param {Number} end  The upper bound of the binning-column.
 * @param {Number} interval  The interval of a bin. Set members fall into bin i
 *                           if the binning-column falls in the range
 *                           [start+interval``*``i, start+interval``*``(i+1)).
 * @param {Object} options  Map of optional parameters:
 *                          <ul>
 *                                  <li> additional_column_names: A list of
 *                          comma separated value-column names over which
 *                          statistics can be accumulated along with the
 *                          primary value_column.
 *                                  <li> bin_values: A list of comma separated
 *                          binning-column values. Values that match the nth
 *                          bin_values value are placed in the nth bin.
 *                                  <li> weight_column_name: Name of the column
 *                          used as weighting column for the weighted_average
 *                          statistic.
 *                                  <li> order_column_name: Name of the column
 *                          used for candlestick charting techniques.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_statistics_by_range = function(table_name, select_expression, column_name, value_column_name, stats, start, end, interval, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_statistics_by_range(table_name, select_expression, column_name, value_column_name, stats, start, end, interval, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        select_expression: (select_expression !== undefined && select_expression !== null) ? select_expression : "",
        column_name: column_name,
        value_column_name: value_column_name,
        stats: stats,
        start: start,
        end: end,
        interval: interval,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/aggregate/statistics/byrange", actual_request, callback);
};

/**
 * Returns all the unique values from a particular column (specified by
 * <code>column_name</code>) of a particular table (specified by
 * <code>table_name</code>). If <code>column_name</code> is a numeric column
 * the values will be in <code>binary_encoded_response</code>. Otherwise if
 * <code>column_name</code> is a string column the values will be in
 * <code>json_encoded_response</code>.  <code>offset</code> and
 * <code>limit</code> are used to page through the results if there are large
 * numbers of unique values. To get the first 10 unique values sorted in
 * descending order <code>options</code> would be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/dynamic_schemas.html" target="_top">dynamic schemas
 * documentation</a>. If the 'result_table' option is provided then the results
 * are stored in a table with the name given in the option and the results are
 * not returned in the response.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_unique_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_unique_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        column_name: request.column_name,
        offset: request.offset,
        limit: (request.limit !== undefined && request.limit !== null) ? request.limit : 10000,
        encoding: (request.encoding !== undefined && request.encoding !== null) ? request.encoding : "json",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/aggregate/unique", actual_request, function(err, data) {
        if (err === null) {
            data.data = GPUdb.decode(data.json_encoded_response);
            delete data.json_encoded_response;
        }

        callback(err, data);
    });
};

/**
 * Returns all the unique values from a particular column (specified by
 * <code>column_name</code>) of a particular table (specified by
 * <code>table_name</code>). If <code>column_name</code> is a numeric column
 * the values will be in <code>binary_encoded_response</code>. Otherwise if
 * <code>column_name</code> is a string column the values will be in
 * <code>json_encoded_response</code>.  <code>offset</code> and
 * <code>limit</code> are used to page through the results if there are large
 * numbers of unique values. To get the first 10 unique values sorted in
 * descending order <code>options</code> would be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/dynamic_schemas.html" target="_top">dynamic schemas
 * documentation</a>. If the 'result_table' option is provided then the results
 * are stored in a table with the name given in the option and the results are
 * not returned in the response.
 *
 * @param {String} table_name  Name of the table on which the operation will be
 *                             performed. Must be an existing table.
 * @param {String} column_name  Name of the column or an expression containing
 *                              one or more column names on which the unique
 *                              function would be applied.
 * @param {Number} offset  A positive integer indicating the number of initial
 *                         results to skip (this can be useful for paging
 *                         through the results).
 * @param {Number} limit  A positive integer indicating the maximum number of
 *                        results to be returned. Or END_OF_SET (-9999) to
 *                        indicate that the max number of results should be
 *                        returned.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> collection_name: Name of a collection
 *                          which is to contain the table specified in
 *                          'result_table', otherwise the table will be a
 *                          top-level table. If the collection does not allow
 *                          duplicate types and it contains a table of the same
 *                          type as the given one, then this table creation
 *                          request will fail.
 *                                  <li> expression: Optional filter expression
 *                          to apply to the table.
 *                                  <li> sort_order: String indicating how the
 *                          returned values should be sorted.
 *                                  <li> result_table: The name of the table
 *                          used to store the results. If present no results
 *                          are returned in the response. Has the same naming
 *                          restrictions as <a
 *                          href="../../concepts/tables.html"
 *                          target="_top">tables</a>.
 *                                  <li> ttl: Sets the TTL of the table
 *                          specified in 'result_table'. The value must be the
 *                          desired TTL in minutes.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_unique = function(table_name, column_name, offset, limit, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_unique(table_name, column_name, offset, limit, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        column_name: column_name,
        offset: offset,
        limit: (limit !== undefined && limit !== null) ? limit : 10000,
        encoding: "json",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/aggregate/unique", actual_request, function(err, data) {
        if (err === null) {
            data.data = GPUdb.decode(data.json_encoded_response);
            delete data.json_encoded_response;
        }

        callback(err, data);
    });
};

/**
 * The {@linkcode GPUdb#alter_system_properties} endpoint is primarily used
 * to simplify the testing of the system and is not expected to be used during
 * normal execution.  Commands are given through the
 * <code>property_updates_map</code> whose keys are commands and values are
 * strings representing integer values (for example '8000') or boolean values
 * ('true' or 'false').
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_system_properties_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_system_properties_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        property_updates_map: request.property_updates_map,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/alter/system/properties", actual_request, callback);
};

/**
 * The {@linkcode GPUdb#alter_system_properties} endpoint is primarily used
 * to simplify the testing of the system and is not expected to be used during
 * normal execution.  Commands are given through the
 * <code>property_updates_map</code> whose keys are commands and values are
 * strings representing integer values (for example '8000') or boolean values
 * ('true' or 'false').
 *
 * @param {Object} property_updates_map  Map containing the properties of the
 *                                       system to be updated. Error if empty.
 *                                       <ul>
 *                                               <li> sm_omp_threads: Set the
 *                                       number of OpenMP threads that will be
 *                                       used to service filter & aggregation
 *                                       requests against collections to the
 *                                       specified integer value.
 *                                               <li> kernel_omp_threads: Set
 *                                       the number of kernel OpenMP threads to
 *                                       the specified integer value.
 *                                               <li>
 *                                       concurrent_kernel_execution: Enables
 *                                       concurrent kernel execution if the
 *                                       value is <code>true</code> and
 *                                       disables it if the value is
 *                                       <code>false</code>.
 *                                               <li> chunk_size: Sets the
 *                                       chunk size of all new sets to the
 *                                       specified integer value.
 *                                               <li> flush_to_disk: Flushes
 *                                       any changes to any tables to the
 *                                       persistent store.  These changes
 *                                       include updates to the vector store,
 *                                       object store, and text search store,
 *                                       Value string is ignored
 *                                               <li> clear_cache: Clears
 *                                       cached results.  Useful to allow
 *                                       repeated timing of endpoints. Value
 *                                       string is ignored
 *                                               <li> communicator_test: Invoke
 *                                       the communicator test and report
 *                                       timing results. Value string is is a
 *                                       comma separated list of <key>=<value>
 *                                       expressions.  Expressions are:
 *                                       num_transactions=<num> where num is
 *                                       the number of request reply
 *                                       transactions to invoke per test;
 *                                       message_size=<bytes> where bytes is
 *                                       the size of the messages to send in
 *                                       bytes; check_values=<enabled> where if
 *                                       enabled is true the value of the
 *                                       messages received are verified.
 *                                               <li>
 *                                       set_message_timers_enabled: Enables
 *                                       the communicator test to collect
 *                                       additional timing statistics when the
 *                                       value string is <code>true</code>.
 *                                       Disables the collection when the value
 *                                       string is <code>false</code>
 *                                               <li> bulk_add_test: Invoke the
 *                                       bulk add test and report timing
 *                                       results. Value string is ignored.
 *                                               <li> network_speed: Invoke the
 *                                       network speed test and report timing
 *                                       results. Value string is a
 *                                       semicolon-separated list of
 *                                       <key>=<value> expressions.  Valid
 *                                       expressions are: seconds=<time> where
 *                                       time is the time in seconds to run the
 *                                       test; data_size=<size> where size is
 *                                       the size in bytes of the block to be
 *                                       transferred; threads=<number of
 *                                       threads>; to_ranks=<space-separated
 *                                       list of ranks> where the list of ranks
 *                                       is the ranks that rank 0 will send
 *                                       data to and get data from. If to_ranks
 *                                       is unspecified then all worker ranks
 *                                       are used.
 *                                               <li> request_timeout: Number
 *                                       of minutes after which filtering
 *                                       (e.g., {@linkcode GPUdb#filter}) and
 *                                       aggregating (e.g.,
 *                                       {@linkcode GPUdb#aggregate_group_by})
 *                                       queries will timeout.
 *                                               <li> max_get_records_size: The
 *                                       maximum number of records the database
 *                                       will serve for a given data retrieval
 *                                       call
 *                                       </ul>
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_system_properties = function(property_updates_map, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_system_properties(property_updates_map, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        property_updates_map: property_updates_map,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/alter/system/properties", actual_request, callback);
};

/**
 * Apply various modifications to a table or collection. Available
 * modifications include:
 * <p>
 *      Creating or deleting an index on a particular column. This can speed up
 * certain search queries (such as {@linkcode GPUdb#get_records},
 * {@linkcode GPUdb#delete_records}, {@linkcode GPUdb#update_records}) when
 * using expressions containing equality or relational operators on indexed
 * columns. This only applies to tables.
 * <p>
 *      Setting the time-to-live (TTL). This can be applied to tables, views,
 * or collections.  When applied to collections, every table & view within the
 * collection will have its TTL set to the given value.
 * <p>
 *      Making a table protected or not. Protected tables have their TTLs set
 * to not automatically expire. This can be applied to tables, views, and
 * collections.
 * <p>
 *      Allowing homogeneous tables within a collection.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        action: request.action,
        value: request.value,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/alter/table", actual_request, callback);
};

/**
 * Apply various modifications to a table or collection. Available
 * modifications include:
 * <p>
 *      Creating or deleting an index on a particular column. This can speed up
 * certain search queries (such as {@linkcode GPUdb#get_records},
 * {@linkcode GPUdb#delete_records}, {@linkcode GPUdb#update_records}) when
 * using expressions containing equality or relational operators on indexed
 * columns. This only applies to tables.
 * <p>
 *      Setting the time-to-live (TTL). This can be applied to tables, views,
 * or collections.  When applied to collections, every table & view within the
 * collection will have its TTL set to the given value.
 * <p>
 *      Making a table protected or not. Protected tables have their TTLs set
 * to not automatically expire. This can be applied to tables, views, and
 * collections.
 * <p>
 *      Allowing homogeneous tables within a collection.
 *
 * @param {String} table_name  Table on which the operation will be performed.
 *                             Must be an existing table, view, or collection.
 * @param {String} action  Modification operation to be applied Values:
 *                         create_index, delete_index,
 *                         allow_homogeneous_tables, protected, ttl,
 *                         add_column, delete_column, change_column,
 *                         rename_table.
 * @param {String} value  The value of the modification. May be a column name,
 *                        'true' or 'false', or a TTL depending on
 *                        <code>action</code>.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> column_default_value: when adding a
 *                          column: set a default value, for existing data.
 *                                  <li> column_properties: when adding or
 *                          changing a column: set the column properties
 *                          (strings, separated by a comma: data, store_only,
 *                          text_search, char8, int8 etc).
 *                                  <li> column_type: when adding or changing a
 *                          column: set the column type (strings, separated by
 *                          a comma: int, double, string, null etc).
 *                                  <li> validate_change_column: Validate the
 *                          type change before applying column_change request.
 *                          Default is true (if option is missing). If True,
 *                          then validate all values. A value too large (or too
 *                          long) for the new type will prevent any change. If
 *                          False, then when a value is too large or long, it
 *                          will be truncated.
 *                                  <li> copy_values_from_column: when adding
 *                          or changing a column: enter column name - from
 *                          where to copy values.
 *                                  <li> rename_column: new column name (using
 *                          change_column).
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_table = function(table_name, action, value, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_table(table_name, action, value, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        action: action,
        value: value,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/alter/table", actual_request, callback);
};

/**
 * Updates (adds or changes) metadata for tables. The metadata key and values
 * must both be strings. This is an easy way to annotate whole tables rather
 * than single records within tables.  Some examples of metadata are owner of
 * the table, table creation timestamp etc.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_table_metadata_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_table_metadata_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: request.table_names,
        metadata_map: request.metadata_map,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/alter/table/metadata", actual_request, callback);
};

/**
 * Updates (adds or changes) metadata for tables. The metadata key and values
 * must both be strings. This is an easy way to annotate whole tables rather
 * than single records within tables.  Some examples of metadata are owner of
 * the table, table creation timestamp etc.
 *
 * @param {String[]} table_names  Names of the tables whose metadata will be
 *                                updated. All specified tables must exist, or
 *                                an error will be returned.
 * @param {Object} metadata_map  A map which contains the metadata of the
 *                               tables that are to be updated. Note that only
 *                               one map is provided for all the tables; so the
 *                               change will be applied to every table. If the
 *                               provided map is empty, then all existing
 *                               metadata for the table(s) will be cleared.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_table_metadata = function(table_names, metadata_map, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_table_metadata(table_names, metadata_map, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: table_names,
        metadata_map: metadata_map,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/alter/table/metadata", actual_request, callback);
};

/**
 * Alters a user.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_user_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_user_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        action: request.action,
        value: request.value,
        options: request.options
    };

    this.submit_request("/alter/user", actual_request, callback);
};

/**
 * Alters a user.
 *
 * @param {String} name  Name of the user to be altered. Must be an existing
 *                       user.
 * @param {String} action  Modification operation to be applied to the user.
 *                         Values: set_password.
 * @param {String} value  The value of the modification, depending on
 *                        <code>action</code>.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_user = function(name, action, value, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_user(name, action, value, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        action: action,
        value: value,
        options: options
    };

    this.submit_request("/alter/user", actual_request, callback);
};

/**
 * Clears (drops) one or all tables in the database cluster. The operation is
 * synchronous meaning that the table will be cleared before the function
 * returns. The response payload returns the status of the operation along with
 * the name of the table that was cleared.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.clear_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.clear_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: (request.table_name !== undefined && request.table_name !== null) ? request.table_name : "",
        authorization: (request.authorization !== undefined && request.authorization !== null) ? request.authorization : "",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/clear/table", actual_request, callback);
};

/**
 * Clears (drops) one or all tables in the database cluster. The operation is
 * synchronous meaning that the table will be cleared before the function
 * returns. The response payload returns the status of the operation along with
 * the name of the table that was cleared.
 *
 * @param {String} table_name  Name of the table to be cleared. Must be an
 *                             existing table. Empty string clears all
 *                             available tables.
 * @param {String} authorization  No longer used. User can pass an empty
 *                                string.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.clear_table = function(table_name, authorization, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.clear_table(table_name, authorization, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: (table_name !== undefined && table_name !== null) ? table_name : "",
        authorization: (authorization !== undefined && authorization !== null) ? authorization : "",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/clear/table", actual_request, callback);
};

/**
 * Deactivates a table monitor previously created with
 * {@linkcode GPUdb#create_table_monitor}.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.clear_table_monitor_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.clear_table_monitor_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        topic_id: request.topic_id,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/clear/tablemonitor", actual_request, callback);
};

/**
 * Deactivates a table monitor previously created with
 * {@linkcode GPUdb#create_table_monitor}.
 *
 * @param {String} topic_id  The topic ID returned by
 *                           {@linkcode GPUdb#create_table_monitor}.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.clear_table_monitor = function(topic_id, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.clear_table_monitor(topic_id, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        topic_id: topic_id,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/clear/tablemonitor", actual_request, callback);
};

/**
 * Clears or cancels the trigger identified by the specified handle. The output
 * returns the handle of the trigger cleared as well as indicating success or
 * failure of the trigger deactivation.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.clear_trigger_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.clear_trigger_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        trigger_id: request.trigger_id,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/clear/trigger", actual_request, callback);
};

/**
 * Clears or cancels the trigger identified by the specified handle. The output
 * returns the handle of the trigger cleared as well as indicating success or
 * failure of the trigger deactivation.
 *
 * @param {String} trigger_id  ID for the trigger to be deactivated.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.clear_trigger = function(trigger_id, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.clear_trigger(trigger_id, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        trigger_id: trigger_id,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/clear/trigger", actual_request, callback);
};

/**
 * Creates a table that is the result of a SQL JOIN.  For details see: <a
 * href="../../concepts/joins.html" target="_top">join concept
 * documentation</a>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_join_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_join_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        join_table_name: request.join_table_name,
        table_names: (request.table_names !== undefined && request.table_names !== null) ? request.table_names : [],
        column_names: (request.column_names !== undefined && request.column_names !== null) ? request.column_names : [],
        expressions: (request.expressions !== undefined && request.expressions !== null) ? request.expressions : [],
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/jointable", actual_request, callback);
};

/**
 * Creates a table that is the result of a SQL JOIN.  For details see: <a
 * href="../../concepts/joins.html" target="_top">join concept
 * documentation</a>.
 *
 * @param {String} join_table_name  Name of the join table to be created.  Has
 *                                  the same naming restrictions as <a
 *                                  href="../../concepts/tables.html"
 *                                  target="_top">tables</a>.
 * @param {String[]} table_names  The list of table names making up the joined
 *                                set.  Corresponds to a SQL statement FROM
 *                                clause
 * @param {String[]} column_names  List of columns to be included in the join
 *                                 table. Can be the column_names from the
 *                                 member sets if unique or can be prefixed by
 *                                 the table id as <id>.<column_name> where
 *                                 <id> is the table name or alias. Can be
 *                                 specified as aliased via the syntax
 *                                 '<column_name> as <alias>. Can use wild
 *                                 cards as '*' (include all columns), or
 *                                 <id>.* (include all columns from table with
 *                                 name or alias <id>)
 * @param {String[]} expressions  An optional list of expressions to combine
 *                                and filter the joined set.  Corresponds to a
 *                                SQL statement WHERE clause. For details see:
 *                                <a href="../../concepts/expressions.html"
 *                                target="_top">expressions</a>.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> collection_name: Name of a collection
 *                          which is to contain the join table. If the
 *                          collection provided is non-existent, the collection
 *                          will be automatically created. If empty, then the
 *                          join table will be a top-level table.
 *                                  <li> max_query_dimensions: The maximum
 *                          number of tables in a joined table that can be
 *                          accessed by a query and are not equated by a
 *                          foreign-key to primary-key equality predicate
 *                                  <li> optimize_lookups: Use the applied
 *                          filters to precalculate the lookup table to get
 *                          data from the primary key sets
 *                                  <li> refresh_method: Method by which the
 *                          join table can be refreshed when underlying member
 *                          tables have changed.
 *                                  <li> refresh: Do a manual refresh of the
 *                          join table if it exists - throws an error otherwise
 *                                  <li> ttl: Sets the TTL of the table
 *                          specified in <code>join_table_name</code>. The
 *                          value must be the desired TTL in minutes.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_join_table = function(join_table_name, table_names, column_names, expressions, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_join_table(join_table_name, table_names, column_names, expressions, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        join_table_name: join_table_name,
        table_names: (table_names !== undefined && table_names !== null) ? table_names : [],
        column_names: (column_names !== undefined && column_names !== null) ? column_names : [],
        expressions: (expressions !== undefined && expressions !== null) ? expressions : [],
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/jointable", actual_request, callback);
};

/**
 * Creates an instance (proc) of the user-defined function (UDF) specified by
 * the given command, options, and files, and makes it available for execution.
 * For details on UDFs, see: <a href="../../concepts/udf.html"
 * target="_top">User-Defined Functions</a>
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_proc_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_proc_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        proc_name: request.proc_name,
        execution_mode: (request.execution_mode !== undefined && request.execution_mode !== null) ? request.execution_mode : "distributed",
        files: (request.files !== undefined && request.files !== null) ? request.files : {},
        command: (request.command !== undefined && request.command !== null) ? request.command : "",
        args: (request.args !== undefined && request.args !== null) ? request.args : [],
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/proc", actual_request, callback);
};

/**
 * Creates an instance (proc) of the user-defined function (UDF) specified by
 * the given command, options, and files, and makes it available for execution.
 * For details on UDFs, see: <a href="../../concepts/udf.html"
 * target="_top">User-Defined Functions</a>
 *
 * @param {String} proc_name  Name of the proc to be created. Must not be the
 *                            name of a currently existing proc.
 * @param {String} execution_mode  The execution mode of the proc.
 * @param {Object} files  A map of the files that make up the proc. The keys of
 *                        the map are file names, and the values are the binary
 *                        contents of the files. The file names may include
 *                        subdirectory names (e.g. 'subdir/file') but must not
 *                        resolve to a directory above the root for the proc.
 * @param {String} command  The command (excluding arguments) that will be
 *                          invoked when the proc is executed. It will be
 *                          invoked from the directory containing the proc
 *                          <code>files</code> and may be any command that can
 *                          be resolved from that directory. It need not refer
 *                          to a file actually in that directory; for example,
 *                          it could be 'java' if the proc is a Java
 *                          application; however, any necessary external
 *                          programs must be preinstalled on every database
 *                          node. If the command refers to a file in that
 *                          directory, it must be preceded with './' as per
 *                          Linux convention. If not specified, and exactly one
 *                          file is provided in <code>files</code>, that file
 *                          will be invoked.
 * @param {String[]} args  An array of command-line arguments that will be
 *                         passed to <code>command</code> when the proc is
 *                         executed.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_proc = function(proc_name, execution_mode, files, command, args, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_proc(proc_name, execution_mode, files, command, args, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        proc_name: proc_name,
        execution_mode: (execution_mode !== undefined && execution_mode !== null) ? execution_mode : "distributed",
        files: (files !== undefined && files !== null) ? files : {},
        command: (command !== undefined && command !== null) ? command : "",
        args: (args !== undefined && args !== null) ? args : [],
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/proc", actual_request, callback);
};

/**
 * Creates a new projection of an existing table.  A projection represents a
 * subset of the columns (potentially including derived columns) of a table.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_projection_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_projection_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        projection_name: request.projection_name,
        column_names: request.column_names,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/projection", actual_request, callback);
};

/**
 * Creates a new projection of an existing table.  A projection represents a
 * subset of the columns (potentially including derived columns) of a table.
 *
 * @param {String} table_name  Name of the existing table on which the
 *                             projection is to be applied.
 * @param {String} projection_name  Name of the projection to be created. Has
 *                                  the same naming restrictions as <a
 *                                  href="../../concepts/tables.html"
 *                                  target="_top">tables</a>.
 * @param {String[]} column_names  List of columns from <code>table_name</code>
 *                                 to be included in the projection. Can
 *                                 include derived columns. Can be specified as
 *                                 aliased via the syntax '<column_name> as
 *                                 <alias>.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> collection_name: Name of a collection
 *                          to which the projection is to be assigned as a
 *                          child. If the collection provided is non-existent,
 *                          the collection will be automatically created.
 *                                  <li> expression: An optional filter
 *                          expression to be applied to the source table prior
 *                          to the projection.
 *                                  <li> limit: The number of records to keep.
 *                                  <li> order_by: Comma-separated list of the
 *                          columns to be sorted by; e.g. 'timestamp asc, x
 *                          desc'.  The columns specified must be present in
 *                          <code>column_names</code>.  If any alias is given
 *                          for any column name, the alias must be used, rather
 *                          than the original column name.
 *                                  <li> materialize_on_gpu: If 'true' then the
 *                          columns of the projection will be cached on the
 *                          GPU.
 *                                  <li> ttl: Sets the TTL of the table, view,
 *                          or collection specified in <code>table_name</code>.
 *                          The value must be the desired TTL in minutes.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_projection = function(table_name, projection_name, column_names, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_projection(table_name, projection_name, column_names, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        projection_name: projection_name,
        column_names: column_names,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/projection", actual_request, callback);
};

/**
 * Creates a new role.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_role_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_role_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        options: request.options
    };

    this.submit_request("/create/role", actual_request, callback);
};

/**
 * Creates a new role.
 *
 * @param {String} name  Name of the role to be created. Must contain only
 *                       lowercase letters, digits, and underscores, and cannot
 *                       begin with a digit. Must not be the same name as an
 *                       existing user or role.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_role = function(name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_role(name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        options: options
    };

    this.submit_request("/create/role", actual_request, callback);
};

/**
 * Creates a new table or collection. If a new table is being created, the type
 * of the table is given by <code>type_id</code>, which must the be the ID of a
 * currently registered type (i.e. one created via
 * {@linkcode GPUdb#create_type}). The table will be created inside a
 * collection if the option <code>collection_name</code> is specified. If that
 * collection does not already exist, it will be created.

 * To create a new collection, specify the name of the collection in
 * <code>table_name</code> and set the <code>is_collection</code> option to
 * <code>true</code>; <code>type_id</code> will be ignored.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        type_id: request.type_id,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/table", actual_request, callback);
};

/**
 * Creates a new table or collection. If a new table is being created, the type
 * of the table is given by <code>type_id</code>, which must the be the ID of a
 * currently registered type (i.e. one created via
 * {@linkcode GPUdb#create_type}). The table will be created inside a
 * collection if the option <code>collection_name</code> is specified. If that
 * collection does not already exist, it will be created.

 * To create a new collection, specify the name of the collection in
 * <code>table_name</code> and set the <code>is_collection</code> option to
 * <code>true</code>; <code>type_id</code> will be ignored.
 *
 * @param {String} table_name  Name of the table to be created. Error for
 *                             requests with existing table of the same name
 *                             and type id may be suppressed by using the
 *                             <code>no_error_if_exists</code> option.  See <a
 *                             href="../../concepts/tables.html"
 *                             target="_top">Tables</a> for naming
 *                             restrictions.
 * @param {String} type_id  ID of a currently registered type. All objects
 *                          added to the newly created table will be of this
 *                          type.  Ignored if <code>is_collection</code> is
 *                          <code>true</code>.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> no_error_if_exists: If
 *                          <code>true</code>, prevents an error from occurring
 *                          if the table already exists and is of the given
 *                          type.  If a table with the same ID but a different
 *                          type exists, it is still an error. Values: true,
 *                          false.
 *                                  <li> collection_name: Name of a collection
 *                          which is to contain the newly created table. If
 *                          empty, then the newly created table will be a
 *                          top-level table. If the collection does not allow
 *                          duplicate types and it contains a table of the same
 *                          type as the given one, then this table creation
 *                          request will fail.
 *                                  <li> is_collection: Indicates whether the
 *                          new table to be created will be a collection.
 *                          Values: true, false.
 *                                  <li> disallow_homogeneous_tables: For a
 *                          collection, indicates whether the collection
 *                          prohibits containment of multiple tables of exactly
 *                          the same data type. Values: true, false.
 *                                  <li> is_replicated: For a table, indicates
 *                          whether the table is to be replicated to all the
 *                          database ranks. This may be necessary when the
 *                          table is to be joined with other tables in a query.
 *                          Values: true, false.
 *                                  <li> foreign_keys: Semicolon-separated list
 *                          of foreign key constraints, of the format
 *                          'source_column references
 *                          target_table(primary_key_column)'.
 *                                  <li> foreign_shard_key: Foreign shard key
 *                          description of the format: <fk_foreign_key>
 *                          references <pk_column_name> from
 *                          <pk_table_name>(<pk_primary_key>)
 *                                  <li> ttl: Sets the TTL of the table or
 *                          collection specified in <code>table_name</code>.
 *                          The value must be the desired TTL in minutes.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_table = function(table_name, type_id, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_table(table_name, type_id, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        type_id: type_id,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/table", actual_request, callback);
};

/**
 * Creates a monitor that watches for new records inserted into a particular
 * table (identified by <code>table_name</code>) and forwards copies to
 * subscribers via ZMQ. After this call completes, subscribe to the returned
 * <code>topic_id</code> on the ZMQ table monitor port (default 9002). Each
 * time an insert operation on the table completes, a multipart message is
 * published for that topic; the first part contains only the topic ID, and
 * each subsequent part contains one binary-encoded Avro object that was
 * inserted. The monitor will continue to run (regardless of whether or not
 * there are any subscribers) until deactivated with
 * {@linkcode GPUdb#clear_table_monitor}.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_table_monitor_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_table_monitor_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/tablemonitor", actual_request, callback);
};

/**
 * Creates a monitor that watches for new records inserted into a particular
 * table (identified by <code>table_name</code>) and forwards copies to
 * subscribers via ZMQ. After this call completes, subscribe to the returned
 * <code>topic_id</code> on the ZMQ table monitor port (default 9002). Each
 * time an insert operation on the table completes, a multipart message is
 * published for that topic; the first part contains only the topic ID, and
 * each subsequent part contains one binary-encoded Avro object that was
 * inserted. The monitor will continue to run (regardless of whether or not
 * there are any subscribers) until deactivated with
 * {@linkcode GPUdb#clear_table_monitor}.
 *
 * @param {String} table_name  Name of the table to monitor. Must not refer to
 *                             a collection.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_table_monitor = function(table_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_table_monitor(table_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/tablemonitor", actual_request, callback);
};

/**
 * Sets up an area trigger mechanism for two column_names for one or more
 * tables. (This function is essentially the two-dimensional version of
 * {@linkcode GPUdb#create_trigger_by_range}.) Once the trigger has been
 * activated, any record added to the listed tables(s) via
 * {@linkcode GPUdb#insert_records} with the chosen columns' values falling
 * within the specified region will trip the trigger. All such records will be
 * queued at the trigger port (by default '9001', but able to be retrieved via
 * {@linkcode GPUdb#show_system_status}) for any listening client to collect.
 * Active triggers can be cancelled by using the
 * {@linkcode GPUdb#clear_trigger} endpoint or by clearing all relevant
 * tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_trigger_by_area_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_trigger_by_area_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        request_id: request.request_id,
        table_names: request.table_names,
        x_column_name: request.x_column_name,
        x_vector: request.x_vector,
        y_column_name: request.y_column_name,
        y_vector: request.y_vector,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/trigger/byarea", actual_request, callback);
};

/**
 * Sets up an area trigger mechanism for two column_names for one or more
 * tables. (This function is essentially the two-dimensional version of
 * {@linkcode GPUdb#create_trigger_by_range}.) Once the trigger has been
 * activated, any record added to the listed tables(s) via
 * {@linkcode GPUdb#insert_records} with the chosen columns' values falling
 * within the specified region will trip the trigger. All such records will be
 * queued at the trigger port (by default '9001', but able to be retrieved via
 * {@linkcode GPUdb#show_system_status}) for any listening client to collect.
 * Active triggers can be cancelled by using the
 * {@linkcode GPUdb#clear_trigger} endpoint or by clearing all relevant
 * tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 *
 * @param {String} request_id  User-created ID for the trigger. The ID can be
 *                             alphanumeric, contain symbols, and must contain
 *                             at least one character.
 * @param {String[]} table_names  Names of the tables on which the trigger will
 *                                be activated and maintained.
 * @param {String} x_column_name  Name of a numeric column on which the trigger
 *                                is activated. Usually 'x' for geospatial data
 *                                points.
 * @param {Number[]} x_vector  The respective coordinate values for the region
 *                             on which the trigger is activated. This usually
 *                             translates to the x-coordinates of a geospatial
 *                             region.
 * @param {String} y_column_name  Name of a second numeric column on which the
 *                                trigger is activated. Usually 'y' for
 *                                geospatial data points.
 * @param {Number[]} y_vector  The respective coordinate values for the region
 *                             on which the trigger is activated. This usually
 *                             translates to the y-coordinates of a geospatial
 *                             region. Must be the same length as xvals.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_trigger_by_area = function(request_id, table_names, x_column_name, x_vector, y_column_name, y_vector, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_trigger_by_area(request_id, table_names, x_column_name, x_vector, y_column_name, y_vector, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        request_id: request_id,
        table_names: table_names,
        x_column_name: x_column_name,
        x_vector: x_vector,
        y_column_name: y_column_name,
        y_vector: y_vector,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/trigger/byarea", actual_request, callback);
};

/**
 * Sets up a simple range trigger for a column_name for one or more tables.
 * Once the trigger has been activated, any record added to the listed
 * tables(s) via {@linkcode GPUdb#insert_records} with the chosen
 * column_name's value falling within the specified range will trip the
 * trigger. All such records will be queued at the trigger port (by default
 * '9001', but able to be retrieved via {@linkcode GPUdb#show_system_status})
 * for any listening client to collect. Active triggers can be cancelled by
 * using the {@linkcode GPUdb#clear_trigger} endpoint or by clearing all
 * relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_trigger_by_range_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_trigger_by_range_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        request_id: request.request_id,
        table_names: request.table_names,
        column_name: request.column_name,
        min: request.min,
        max: request.max,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/trigger/byrange", actual_request, callback);
};

/**
 * Sets up a simple range trigger for a column_name for one or more tables.
 * Once the trigger has been activated, any record added to the listed
 * tables(s) via {@linkcode GPUdb#insert_records} with the chosen
 * column_name's value falling within the specified range will trip the
 * trigger. All such records will be queued at the trigger port (by default
 * '9001', but able to be retrieved via {@linkcode GPUdb#show_system_status})
 * for any listening client to collect. Active triggers can be cancelled by
 * using the {@linkcode GPUdb#clear_trigger} endpoint or by clearing all
 * relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 *
 * @param {String} request_id  User-created ID for the trigger. The ID can be
 *                             alphanumeric, contain symbols, and must contain
 *                             at least one character.
 * @param {String[]} table_names  Tables on which the trigger will be active.
 * @param {String} column_name  Name of a numeric column_name on which the
 *                              trigger is activated.
 * @param {Number} min  The lower bound (inclusive) for the trigger range.
 * @param {Number} max  The upper bound (inclusive) for the trigger range.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_trigger_by_range = function(request_id, table_names, column_name, min, max, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_trigger_by_range(request_id, table_names, column_name, min, max, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        request_id: request_id,
        table_names: table_names,
        column_name: column_name,
        min: min,
        max: max,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/trigger/byrange", actual_request, callback);
};

/**
 * Creates a new type describing the layout or schema of a table. The type
 * definition is a JSON string describing the fields (i.e. columns) of the
 * type. Each field consists of a name and a data type. Supported data types
 * are: double, float, int, long, string, and bytes. In addition one or more
 * properties can be specified for each column which customize the memory usage
 * and query availability of that column.  Note that some properties are
 * mutually exclusive--i.e. they cannot be specified for any given column
 * simultaneously.  One example of mutually exclusive properties are
 * <code>data</code> and <code>store_only</code>.
 * <p>
 * To set a *primary key* on one or more columns include the property
 * 'primary_key' on the desired column_names. If a primary key is specified,
 * then a uniqueness constraint is enforced, in that only a single object can
 * exist with a given primary key. When
 * [inserting]{@linkcode GPUdb#insert_records} data into a table with a
 * primary key, depending on the parameters in the request, incoming objects
 * with primary keys that match existing objects will either overwrite (i.e.
 * update) the existing object or will be skipped and not added into the set.
 * <p>
 * Example of a type definition with some of the parameters::
 * <p>
 *         {"type":"record",
 *         "name":"point",
 *         "fields":[{"name":"msg_id","type":"string"},
 *                         {"name":"x","type":"double"},
 *                         {"name":"y","type":"double"},
 *                         {"name":"TIMESTAMP","type":"double"},
 *                         {"name":"source","type":"string"},
 *                         {"name":"group_id","type":"string"},
 *                         {"name":"OBJECT_ID","type":"string"}]
 *         }
 * <p>
 * Properties::
 * <p>
 *         {"group_id":["store_only"],
 *         "msg_id":["store_only","text_search"]
 *         }
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_type_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_type_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        type_definition: request.type_definition,
        label: request.label,
        properties: (request.properties !== undefined && request.properties !== null) ? request.properties : {},
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/type", actual_request, callback);
};

/**
 * Creates a new type describing the layout or schema of a table. The type
 * definition is a JSON string describing the fields (i.e. columns) of the
 * type. Each field consists of a name and a data type. Supported data types
 * are: double, float, int, long, string, and bytes. In addition one or more
 * properties can be specified for each column which customize the memory usage
 * and query availability of that column.  Note that some properties are
 * mutually exclusive--i.e. they cannot be specified for any given column
 * simultaneously.  One example of mutually exclusive properties are
 * <code>data</code> and <code>store_only</code>.
 * <p>
 * To set a *primary key* on one or more columns include the property
 * 'primary_key' on the desired column_names. If a primary key is specified,
 * then a uniqueness constraint is enforced, in that only a single object can
 * exist with a given primary key. When
 * [inserting]{@linkcode GPUdb#insert_records} data into a table with a
 * primary key, depending on the parameters in the request, incoming objects
 * with primary keys that match existing objects will either overwrite (i.e.
 * update) the existing object or will be skipped and not added into the set.
 * <p>
 * Example of a type definition with some of the parameters::
 * <p>
 *         {"type":"record",
 *         "name":"point",
 *         "fields":[{"name":"msg_id","type":"string"},
 *                         {"name":"x","type":"double"},
 *                         {"name":"y","type":"double"},
 *                         {"name":"TIMESTAMP","type":"double"},
 *                         {"name":"source","type":"string"},
 *                         {"name":"group_id","type":"string"},
 *                         {"name":"OBJECT_ID","type":"string"}]
 *         }
 * <p>
 * Properties::
 * <p>
 *         {"group_id":["store_only"],
 *         "msg_id":["store_only","text_search"]
 *         }
 *
 * @param {String} type_definition  a JSON string describing the columns of the
 *                                  type to be registered.
 * @param {String} label  A user-defined description string which can be used
 *                        to differentiate between tables and types with
 *                        otherwise identical schemas.
 * @param {Object} properties  Each key-value pair specifies the properties to
 *                             use for a given column where the key is the
 *                             column name.  All keys used must be relevant
 *                             column names for the given table.  Specifying
 *                             any property overrides the default properties
 *                             for that column (which is based on the column's
 *                             data type).
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_type = function(type_definition, label, properties, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_type(type_definition, label, properties, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        type_definition: type_definition,
        label: label,
        properties: (properties !== undefined && properties !== null) ? properties : {},
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/type", actual_request, callback);
};

/**
 * Creates a table that is the concatenation of one or more existing tables. It
 * is equivalent to the SQL UNION ALL operator.  Non-charN 'string' and 'bytes'
 * column types cannot be included in a union, neither can columns with the
 * property 'store_only'.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_union_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_union_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        table_names: request.table_names,
        input_column_names: request.input_column_names,
        output_column_names: request.output_column_names,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/union", actual_request, callback);
};

/**
 * Creates a table that is the concatenation of one or more existing tables. It
 * is equivalent to the SQL UNION ALL operator.  Non-charN 'string' and 'bytes'
 * column types cannot be included in a union, neither can columns with the
 * property 'store_only'.
 *
 * @param {String} table_name  Name of the table to be created. Has the same
 *                             naming restrictions as <a
 *                             href="../../concepts/tables.html"
 *                             target="_top">tables</a>.
 * @param {String[]} table_names  The list of table names making up the union.
 *                                Must contain the names of one or more
 *                                existing tables.
 * @param {String[][]} input_column_names  The list of columns from each of the
 *                                         corresponding input tables.
 * @param {String[]} output_column_names  The list of names of the columns to
 *                                        be stored in the union.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> collection_name: Name of a collection
 *                          which is to contain the union. If the collection
 *                          provided is non-existent, the collection will be
 *                          automatically created. If empty, then the union
 *                          will be a top-level table.
 *                                  <li> materialize_on_gpu: If 'true' then the
 *                          columns of the union will be cached on the GPU.
 *                                  <li> mode: If 'merge_views' then this
 *                          operation will merge (i.e. union) the provided
 *                          views. All 'table_names' must be views from the
 *                          same underlying base table.
 *                                  <li> ttl: Sets the TTL of the table
 *                          specified in <code>table_name</code>. The value
 *                          must be the desired TTL in minutes.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_union = function(table_name, table_names, input_column_names, output_column_names, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_union(table_name, table_names, input_column_names, output_column_names, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        table_names: table_names,
        input_column_names: input_column_names,
        output_column_names: output_column_names,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/union", actual_request, callback);
};

/**
 * Creates a new external user (a user whose credentials are managed by an
 * external LDAP).
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_user_external_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_user_external_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        options: request.options
    };

    this.submit_request("/create/user/external", actual_request, callback);
};

/**
 * Creates a new external user (a user whose credentials are managed by an
 * external LDAP).
 *
 * @param {String} name  Name of the user to be created. Must exactly match the
 *                       user's name in the external LDAP, prefixed with a @.
 *                       Must not be the same name as an existing user.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_user_external = function(name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_user_external(name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        options: options
    };

    this.submit_request("/create/user/external", actual_request, callback);
};

/**
 * Creates a new internal user (a user whose credentials are managed by the
 * database system).
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_user_internal_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_user_internal_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        password: request.password,
        options: request.options
    };

    this.submit_request("/create/user/internal", actual_request, callback);
};

/**
 * Creates a new internal user (a user whose credentials are managed by the
 * database system).
 *
 * @param {String} name  Name of the user to be created. Must contain only
 *                       lowercase letters, digits, and underscores, and cannot
 *                       begin with a digit. Must not be the same name as an
 *                       existing user or role.
 * @param {String} password  Initial password of the user to be created. May be
 *                           an empty string for no password.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_user_internal = function(name, password, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_user_internal(name, password, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        password: password,
        options: options
    };

    this.submit_request("/create/user/internal", actual_request, callback);
};

/**
 * Deletes a proc. Any currently running instances of the proc will be killed.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.delete_proc_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.delete_proc_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        proc_name: request.proc_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/delete/proc", actual_request, callback);
};

/**
 * Deletes a proc. Any currently running instances of the proc will be killed.
 *
 * @param {String} proc_name  Name of the proc to be deleted. Must be the name
 *                            of a currently existing proc.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.delete_proc = function(proc_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.delete_proc(proc_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        proc_name: proc_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/delete/proc", actual_request, callback);
};

/**
 * Deletes record(s) matching the provided criteria from the given table. The
 * record selection criteria can either be one or more
 * <code>expressions</code> (matching multiple records) or a single record
 * identified by <code>record_id</code> options.  Note that the two selection
 * criteria are mutually exclusive.  This operation cannot be run on a
 * collection or a view.  The operation is synchronous meaning that a response
 * will not be available until the request is completely processed and all the
 * matching records are deleted.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.delete_records_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.delete_records_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        expressions: request.expressions,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/delete/records", actual_request, callback);
};

/**
 * Deletes record(s) matching the provided criteria from the given table. The
 * record selection criteria can either be one or more
 * <code>expressions</code> (matching multiple records) or a single record
 * identified by <code>record_id</code> options.  Note that the two selection
 * criteria are mutually exclusive.  This operation cannot be run on a
 * collection or a view.  The operation is synchronous meaning that a response
 * will not be available until the request is completely processed and all the
 * matching records are deleted.
 *
 * @param {String} table_name  Name of the table from which to delete records.
 *                             The set must be a currently existing table and
 *                             not a collection or a view.
 * @param {String[]} expressions  A list of the actual predicates, one for each
 *                                select; format should follow the guidelines
 *                                provided [here]{@linkcode GPUdb#filter}.
 *                                Specifying one or more
 *                                <code>expressions</code> is mutually
 *                                exclusive to specifying
 *                                <code>record_id</code> in the
 *                                <code>options</code>.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> global_expression: An optional global
 *                          expression to reduce the search space of the
 *                          <code>expressions</code>.
 *                                  <li> record_id: A record id identifying a
 *                          single record, obtained at the time of
 *                          [insertion of the record]{@linkcode GPUdb#insert_records}
 *                          or by calling
 *                          {@linkcode GPUdb#get_records_from_collection}
 *                          with the *return_record_ids* option.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.delete_records = function(table_name, expressions, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.delete_records(table_name, expressions, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        expressions: expressions,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/delete/records", actual_request, callback);
};

/**
 * Deletes an existing role.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.delete_role_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.delete_role_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        options: request.options
    };

    this.submit_request("/delete/role", actual_request, callback);
};

/**
 * Deletes an existing role.
 *
 * @param {String} name  Name of the role to be deleted. Must be an existing
 *                       role.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.delete_role = function(name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.delete_role(name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        options: options
    };

    this.submit_request("/delete/role", actual_request, callback);
};

/**
 * Deletes an existing user.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.delete_user_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.delete_user_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        options: request.options
    };

    this.submit_request("/delete/user", actual_request, callback);
};

/**
 * Deletes an existing user.
 *
 * @param {String} name  Name of the user to be deleted. Must be an existing
 *                       user.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.delete_user = function(name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.delete_user(name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        options: options
    };

    this.submit_request("/delete/user", actual_request, callback);
};

/**
 * Executes a proc. This endpoint is asynchronous and does not wait for the
 * proc to complete before returning.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.execute_proc_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.execute_proc_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        proc_name: request.proc_name,
        params: (request.params !== undefined && request.params !== null) ? request.params : {},
        bin_params: (request.bin_params !== undefined && request.bin_params !== null) ? request.bin_params : {},
        input_table_names: (request.input_table_names !== undefined && request.input_table_names !== null) ? request.input_table_names : [],
        input_column_names: (request.input_column_names !== undefined && request.input_column_names !== null) ? request.input_column_names : {},
        output_table_names: (request.output_table_names !== undefined && request.output_table_names !== null) ? request.output_table_names : [],
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/execute/proc", actual_request, callback);
};

/**
 * Executes a proc. This endpoint is asynchronous and does not wait for the
 * proc to complete before returning.
 *
 * @param {String} proc_name  Name of the proc to execute. Must be the name of
 *                            a currently existing proc.
 * @param {Object} params  A map containing named parameters to pass to the
 *                         proc. Each key/value pair specifies the name of a
 *                         parameter and its value.
 * @param {Object} bin_params  A map containing named binary parameters to pass
 *                             to the proc. Each key/value pair specifies the
 *                             name of a parameter and its value.
 * @param {String[]} input_table_names  Names of the tables containing data to
 *                                      be passed to the proc. Each name
 *                                      specified must be the name of a
 *                                      currently existing table. If no table
 *                                      names are specified, no data will be
 *                                      passed to the proc.
 * @param {Object} input_column_names  Map of table names from
 *                                     <code>input_table_names</code> to lists
 *                                     of names of columns from those tables
 *                                     that will be passed to the proc. Each
 *                                     column name specified must be the name
 *                                     of an existing column in the
 *                                     corresponding table. If a table name
 *                                     from <code>input_table_names</code> is
 *                                     not included, all columns from that
 *                                     table will be passed to the proc.
 * @param {String[]} output_table_names  Names of the tables to which output
 *                                       data from the proc will be written. If
 *                                       a specified table does not exist, it
 *                                       will automatically be created with the
 *                                       same schema as the corresponding table
 *                                       (by order) from
 *                                       <code>input_table_names</code>,
 *                                       excluding any primary and shard keys.
 *                                       If no table names are specified, no
 *                                       output data can be returned from the
 *                                       proc.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> cache_input: A comma-delimited list of
 *                          table names from <code>input_table_names</code>
 *                          from which input data will be cached for use in
 *                          subsequent calls to
 *                          {@linkcode GPUdb#execute_proc} with the
 *                          <code>use_cached_input</code> option. Cached input
 *                          data will be retained until the proc status is
 *                          cleared with the
 *                          [clear_complete]{@linkcode GPUdb#show_proc_status}
 *                          option of {@linkcode GPUdb#show_proc_status} and
 *                          all proc instances using the cached data have
 *                          completed.
 *                                  <li> use_cached_input: A comma-delimited
 *                          list of run IDs (as returned from prior calls to
 *                          {@linkcode GPUdb#execute_proc}) of running or
 *                          completed proc instances from which input data
 *                          cached using the <code>cache_input</code> option
 *                          will be used. Cached input data will not be used
 *                          for any tables specified in
 *                          <code>input_table_names</code>, but data from all
 *                          other tables cached for the specified run IDs will
 *                          be passed to the proc. If the same table was cached
 *                          for multiple specified run IDs, the cached data
 *                          from the first run ID specified in the list that
 *                          includes that table will be used.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.execute_proc = function(proc_name, params, bin_params, input_table_names, input_column_names, output_table_names, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.execute_proc(proc_name, params, bin_params, input_table_names, input_column_names, output_table_names, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        proc_name: proc_name,
        params: (params !== undefined && params !== null) ? params : {},
        bin_params: (bin_params !== undefined && bin_params !== null) ? bin_params : {},
        input_table_names: (input_table_names !== undefined && input_table_names !== null) ? input_table_names : [],
        input_column_names: (input_column_names !== undefined && input_column_names !== null) ? input_column_names : {},
        output_table_names: (output_table_names !== undefined && output_table_names !== null) ? output_table_names : [],
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/execute/proc", actual_request, callback);
};

/**
 * Filters data based on the specified expression.  The results are stored in a
 * result set with the given <code>view_name</code>.
 * <p>
 * For details see <a href="../../concepts/expressions.html"
 * target="_top">concepts</a>.
 * <p>
 * The response message contains the number of points for which the expression
 * evaluated to be true, which is equivalent to the size of the result view.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        expression: request.expression,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter", actual_request, callback);
};

/**
 * Filters data based on the specified expression.  The results are stored in a
 * result set with the given <code>view_name</code>.
 * <p>
 * For details see <a href="../../concepts/expressions.html"
 * target="_top">concepts</a>.
 * <p>
 * The response message contains the number of points for which the expression
 * evaluated to be true, which is equivalent to the size of the result view.
 *
 * @param {String} table_name  Name of the table to filter.  This may be the ID
 *                             of a collection, table or a result set (for
 *                             chaining queries).  Collections may be filtered
 *                             only if all tables within the collection have
 *                             the same type ID.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results. Has the same naming
 *                            restrictions as <a
 *                            href="../../concepts/tables.html"
 *                            target="_top">tables</a>.
 * @param {String} expression  The select expression to filter the specified
 *                             table.  For details see <a
 *                             href="../../concepts/expressions.html"
 *                             target="_top">concepts</a>.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> collection_name: Name of a collection
 *                          which is to contain the newly created view,
 *                          otherwise the view will be a top-level table. If
 *                          the collection does not allow duplicate types and
 *                          it contains a table of the same type as the given
 *                          one, then this table creation request will fail.
 *                                  <li> ttl: Sets the TTL of the view
 *                          specified in <code>view_name</code>. The value must
 *                          be the desired TTL in minutes.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter = function(table_name, view_name, expression, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter(table_name, view_name, expression, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        expression: expression,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter", actual_request, callback);
};

/**
 * Calculates which objects from a table are within a named area of interest
 * (NAI/polygon). The operation is synchronous, meaning that a response will
 * not be returned until all the matching objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set (view) which satisfies the input NAI restriction specification is
 * created with the name <code>view_name</code> passed in as part of the input.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_area_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_area_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        x_column_name: request.x_column_name,
        x_vector: request.x_vector,
        y_column_name: request.y_column_name,
        y_vector: request.y_vector,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/byarea", actual_request, callback);
};

/**
 * Calculates which objects from a table are within a named area of interest
 * (NAI/polygon). The operation is synchronous, meaning that a response will
 * not be returned until all the matching objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set (view) which satisfies the input NAI restriction specification is
 * created with the name <code>view_name</code> passed in as part of the input.
 *
 * @param {String} table_name  Name of the table to filter.  This may be the
 *                             name of a collection, a table or a view (when
 *                             chaining queries).  Collections may be filtered
 *                             only if all tables within the collection have
 *                             the same type ID.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results. Has the same naming
 *                            restrictions as <a
 *                            href="../../concepts/tables.html"
 *                            target="_top">tables</a>.
 * @param {String} x_column_name  Name of the column containing the x values to
 *                                be filtered.
 * @param {Number[]} x_vector  List of x coordinates of the vertices of the
 *                             polygon representing the area to be filtered.
 * @param {String} y_column_name  Name of the column containing the y values to
 *                                be filtered.
 * @param {Number[]} y_vector  List of y coordinates of the vertices of the
 *                             polygon representing the area to be filtered.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_area = function(table_name, view_name, x_column_name, x_vector, y_column_name, y_vector, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_area(table_name, view_name, x_column_name, x_vector, y_column_name, y_vector, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        x_column_name: x_column_name,
        x_vector: x_vector,
        y_column_name: y_column_name,
        y_vector: y_vector,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/byarea", actual_request, callback);
};

/**
 * Calculates how many objects within the given table lie in a rectangular box.
 * The operation is synchronous, meaning that a response will not be returned
 * until all the objects are fully available. The response payload provides the
 * count of the resulting set. A new resultant set which satisfies the input
 * NAI restriction specification is also created when a <code>view_name</code>
 * is passed in as part of the input payload.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_box_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_box_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        x_column_name: request.x_column_name,
        min_x: request.min_x,
        max_x: request.max_x,
        y_column_name: request.y_column_name,
        min_y: request.min_y,
        max_y: request.max_y,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/bybox", actual_request, callback);
};

/**
 * Calculates how many objects within the given table lie in a rectangular box.
 * The operation is synchronous, meaning that a response will not be returned
 * until all the objects are fully available. The response payload provides the
 * count of the resulting set. A new resultant set which satisfies the input
 * NAI restriction specification is also created when a <code>view_name</code>
 * is passed in as part of the input payload.
 *
 * @param {String} table_name  Name of the table on which the bounding box
 *                             operation will be performed. Must be an existing
 *                             table.
 * @param {String} view_name  Optional name of the result view that will be
 *                            created containing the results of the query. Has
 *                            the same naming restrictions as <a
 *                            href="../../concepts/tables.html"
 *                            target="_top">tables</a>.
 * @param {String} x_column_name  Name of the column on which to perform the
 *                                bounding box query. If the table's data type
 *                                is not a shape type, must be a valid numeric
 *                                column.
 * @param {Number} min_x  Lower bound for the column chosen by
 *                        <code>x_column_name</code>.  Must be less than or
 *                        equal to <code>max_x</code>.
 * @param {Number} max_x  Upper bound for <code>x_column_name</code>.  Must be
 *                        greater than or equal to <code>min_x</code>.
 * @param {String} y_column_name  Name of a column on which to perform the
 *                                bounding box query. If the table's data type
 *                                is not a shape type, must be a valid numeric
 *                                column.
 * @param {Number} min_y  Lower bound for <code>y_column_name</code>. Must be
 *                        less than or equal to <code>max_y</code>.
 * @param {Number} max_y  Upper bound for <code>y_column_name</code>. Must be
 *                        greater than or equal to <code>min_y</code>.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_box = function(table_name, view_name, x_column_name, min_x, max_x, y_column_name, min_y, max_y, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_box(table_name, view_name, x_column_name, min_x, max_x, y_column_name, min_y, max_y, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        x_column_name: x_column_name,
        min_x: min_x,
        max_x: max_x,
        y_column_name: y_column_name,
        min_y: min_y,
        max_y: max_y,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/bybox", actual_request, callback);
};

/**
 * Applies a geometry filter against a spatial column named WKT in a given
 * table, collection or view. The filtering geometry is provided by
 * <code>input_wkt</code>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_geometry_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_geometry_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        column_name: request.column_name,
        input_wkt: (request.input_wkt !== undefined && request.input_wkt !== null) ? request.input_wkt : "",
        operation: request.operation,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/bygeometry", actual_request, callback);
};

/**
 * Applies a geometry filter against a spatial column named WKT in a given
 * table, collection or view. The filtering geometry is provided by
 * <code>input_wkt</code>.
 *
 * @param {String} table_name  Name of the table on which the filter by
 *                             geometry will be performed.  Must be an existing
 *                             table, collection or view containing a column
 *                             named WKT.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results. Has the same naming
 *                            restrictions as <a
 *                            href="../../concepts/tables.html"
 *                            target="_top">tables</a>.
 * @param {String} column_name  Name of the column to be used in the filter.
 *                              Must be 'WKT'
 * @param {String} input_wkt  A geometry in WKT format that will be used to
 *                            filter the objects in <code>table_name</code>.
 * @param {String} operation  The geometric filtering operation to perform
 *                            Values: contains, crosses, disjoint, equals,
 *                            intersects, overlaps, touches, within.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_geometry = function(table_name, view_name, column_name, input_wkt, operation, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_geometry(table_name, view_name, column_name, input_wkt, operation, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        column_name: column_name,
        input_wkt: (input_wkt !== undefined && input_wkt !== null) ? input_wkt : "",
        operation: operation,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/bygeometry", actual_request, callback);
};

/**
 * Calculates which records from a table have values in the given list for the
 * corresponding column. The operation is synchronous, meaning that a response
 * will not be returned until all the objects are fully available. The response
 * payload provides the count of the resulting set. A new resultant set (view)
 * which satisfies the input filter specification is also created if a
 * <code>view_name</code> is passed in as part of the request.
 * <p>
 * For example, if a type definition has the columns 'x' and 'y', then a filter
 * by list query with the column map {"x":["10.1", "2.3"], "y":["0.0", "-31.5",
 * "42.0"]} will return the count of all data points whose x and y values match
 * one of the values in the respective x- and y-lists. If the filter_mode
 * option is set to 'not_in_list' then the filter will match all items that are
 * not in the provided list(s).
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_list_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_list_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        column_values_map: request.column_values_map,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/bylist", actual_request, callback);
};

/**
 * Calculates which records from a table have values in the given list for the
 * corresponding column. The operation is synchronous, meaning that a response
 * will not be returned until all the objects are fully available. The response
 * payload provides the count of the resulting set. A new resultant set (view)
 * which satisfies the input filter specification is also created if a
 * <code>view_name</code> is passed in as part of the request.
 * <p>
 * For example, if a type definition has the columns 'x' and 'y', then a filter
 * by list query with the column map {"x":["10.1", "2.3"], "y":["0.0", "-31.5",
 * "42.0"]} will return the count of all data points whose x and y values match
 * one of the values in the respective x- and y-lists. If the filter_mode
 * option is set to 'not_in_list' then the filter will match all items that are
 * not in the provided list(s).
 *
 * @param {String} table_name  Name of the table to filter.  This may be the ID
 *                             of a collection, table or a result set (for
 *                             chaining queries).  Collections may be filtered
 *                             only if all tables within the collection have
 *                             the same type ID.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results. Has the same naming
 *                            restrictions as <a
 *                            href="../../concepts/tables.html"
 *                            target="_top">tables</a>.
 * @param {Object} column_values_map  List of values for the corresponding
 *                                    column in the table
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> filter_mode: String indicating the
 *                          filter mode, either 'in_list' or 'not_in_list'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_list = function(table_name, view_name, column_values_map, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_list(table_name, view_name, column_values_map, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        column_values_map: column_values_map,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/bylist", actual_request, callback);
};

/**
 * Calculates which objects from a table lie within a circle with the given
 * radius and center point (i.e. circular NAI). The operation is synchronous,
 * meaning that a response will not be returned until all the objects are fully
 * available. The response payload provides the count of the resulting set. A
 * new resultant set (view) which satisfies the input circular NAI restriction
 * specification is also created if a <code>view_name</code> is passed in as
 * part of the request.
 * <p>
 * For track data, all track points that lie within the circle plus one point
 * on either side of the circle (if the track goes beyond the circle) will be
 * included in the result. For shapes, e.g. polygons, all polygons that
 * intersect the circle will be included (even if none of the points of the
 * polygon fall within the circle).
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_radius_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_radius_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        x_column_name: request.x_column_name,
        x_center: request.x_center,
        y_column_name: request.y_column_name,
        y_center: request.y_center,
        radius: request.radius,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/byradius", actual_request, callback);
};

/**
 * Calculates which objects from a table lie within a circle with the given
 * radius and center point (i.e. circular NAI). The operation is synchronous,
 * meaning that a response will not be returned until all the objects are fully
 * available. The response payload provides the count of the resulting set. A
 * new resultant set (view) which satisfies the input circular NAI restriction
 * specification is also created if a <code>view_name</code> is passed in as
 * part of the request.
 * <p>
 * For track data, all track points that lie within the circle plus one point
 * on either side of the circle (if the track goes beyond the circle) will be
 * included in the result. For shapes, e.g. polygons, all polygons that
 * intersect the circle will be included (even if none of the points of the
 * polygon fall within the circle).
 *
 * @param {String} table_name  Name of the table on which the filter by radius
 *                             operation will be performed.  Must be an
 *                             existing table.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results. Has the same naming
 *                            restrictions as <a
 *                            href="../../concepts/tables.html"
 *                            target="_top">tables</a>.
 * @param {String} x_column_name  Name of the column to be used for the
 *                                x-coordinate (the longitude) of the center.
 * @param {Number} x_center  Value of the longitude of the center. Must be
 *                           within [-180.0, 180.0].
 * @param {String} y_column_name  Name of the column to be used for the
 *                                y-coordinate-the latitude-of the center.
 * @param {Number} y_center  Value of the latitude of the center. Must be
 *                           within [-90.0, 90.0].
 * @param {Number} radius  The radius of the circle within which the search
 *                         will be performed. Must be a non-zero positive
 *                         value. It is in meters; so, for example, a value of
 *                         '42000' means 42 km.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_radius = function(table_name, view_name, x_column_name, x_center, y_column_name, y_center, radius, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_radius(table_name, view_name, x_column_name, x_center, y_column_name, y_center, radius, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        x_column_name: x_column_name,
        x_center: x_center,
        y_column_name: y_column_name,
        y_center: y_center,
        radius: radius,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/byradius", actual_request, callback);
};

/**
 * Calculates which objects from a table have a column that is within the given
 * bounds. An object from the table identified by <code>table_name</code> is
 * added to the view <code>view_name</code> if its column is within
 * [<code>lower_bound</code>, <code>upper_bound</code>] (inclusive). The
 * operation is synchronous. The response provides a count of the number of
 * objects which passed the bound filter.  Although this functionality can also
 * be accomplished with the standard filter function, it is more efficient.
 * <p>
 * For track objects, the count reflects how many points fall within the given
 * bounds (which may not include all the track points of any given track).
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_range_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_range_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        column_name: request.column_name,
        lower_bound: request.lower_bound,
        upper_bound: request.upper_bound,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/byrange", actual_request, callback);
};

/**
 * Calculates which objects from a table have a column that is within the given
 * bounds. An object from the table identified by <code>table_name</code> is
 * added to the view <code>view_name</code> if its column is within
 * [<code>lower_bound</code>, <code>upper_bound</code>] (inclusive). The
 * operation is synchronous. The response provides a count of the number of
 * objects which passed the bound filter.  Although this functionality can also
 * be accomplished with the standard filter function, it is more efficient.
 * <p>
 * For track objects, the count reflects how many points fall within the given
 * bounds (which may not include all the track points of any given track).
 *
 * @param {String} table_name  Name of the table on which the filter by range
 *                             operation will be performed.  Must be an
 *                             existing table.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results. Has the same naming
 *                            restrictions as <a
 *                            href="../../concepts/tables.html"
 *                            target="_top">tables</a>.
 * @param {String} column_name  Name of a column on which the operation would
 *                              be applied.
 * @param {Number} lower_bound  Value of the lower bound (inclusive).
 * @param {Number} upper_bound  Value of the upper bound (inclusive).
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_range = function(table_name, view_name, column_name, lower_bound, upper_bound, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_range(table_name, view_name, column_name, lower_bound, upper_bound, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        column_name: column_name,
        lower_bound: lower_bound,
        upper_bound: upper_bound,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/byrange", actual_request, callback);
};

/**
 * Filters objects matching all points of the given track (works only on track
 * type data).  It allows users to specify a particular track to find all other
 * points in the table that fall within specified ranges-spatial and
 * temporal-of all points of the given track. Additionally, the user can
 * specify another track to see if the two intersect (or go close to each other
 * within the specified ranges). The user also has the flexibility of using
 * different metrics for the spatial distance calculation: Euclidean (flat
 * geometry) or Great Circle (spherical geometry to approximate the Earth's
 * surface distances). The filtered points are stored in a newly created result
 * set. The return value of the function is the number of points in the
 * resultant set (view).
 * <p>
 * This operation is synchronous, meaning that a response will not be returned
 * until all the objects are fully available.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_series_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_series_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        track_id: request.track_id,
        target_track_ids: request.target_track_ids,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/byseries", actual_request, callback);
};

/**
 * Filters objects matching all points of the given track (works only on track
 * type data).  It allows users to specify a particular track to find all other
 * points in the table that fall within specified ranges-spatial and
 * temporal-of all points of the given track. Additionally, the user can
 * specify another track to see if the two intersect (or go close to each other
 * within the specified ranges). The user also has the flexibility of using
 * different metrics for the spatial distance calculation: Euclidean (flat
 * geometry) or Great Circle (spherical geometry to approximate the Earth's
 * surface distances). The filtered points are stored in a newly created result
 * set. The return value of the function is the number of points in the
 * resultant set (view).
 * <p>
 * This operation is synchronous, meaning that a response will not be returned
 * until all the objects are fully available.
 *
 * @param {String} table_name  Name of the table on which the filter by track
 *                             operation will be performed. Must be a currently
 *                             existing table with track semantic type.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results. Has the same naming
 *                            restrictions as <a
 *                            href="../../concepts/tables.html"
 *                            target="_top">tables</a>.
 * @param {String} track_id  The ID of the track which will act as the
 *                           filtering points. Must be an existing track within
 *                           the given table.
 * @param {String[]} target_track_ids  Up to one track ID to intersect with the
 *                                     "filter" track. If any provided, it must
 *                                     be an valid track ID within the given
 *                                     set.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> spatial_radius: A positive number
 *                          passed as a string representing the radius of the
 *                          search area centered around each track point's
 *                          geospatial coordinates. The value is interpreted in
 *                          meters. Required parameter.
 *                                  <li> time_radius: A positive number passed
 *                          as a string representing the maximum allowable time
 *                          difference between the timestamps of a filtered
 *                          object and the given track's points. The value is
 *                          interpreted in seconds. Required parameter.
 *                                  <li> spatial_distance_metric: A string
 *                          representing the coordinate system to use for the
 *                          spatial search criteria. Acceptable values are
 *                          'euclidean' and 'great_circle'. Optional parameter;
 *                          default is 'euclidean'. Values: euclidean,
 *                          great_circle.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_series = function(table_name, view_name, track_id, target_track_ids, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_series(table_name, view_name, track_id, target_track_ids, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        track_id: track_id,
        target_track_ids: target_track_ids,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/byseries", actual_request, callback);
};

/**
 * Calculates which objects from a table, collection, or view match a string
 * expression for the given string columns. The options 'case_sensitive' can be
 * used to modify the behavior for all modes except 'search'. For 'search' mode
 * details and limitations, see <a href="../../concepts/full_text_search.html"
 * target="_top">Full Text Search</a>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_string_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_string_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        expression: request.expression,
        mode: request.mode,
        column_names: request.column_names,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/bystring", actual_request, callback);
};

/**
 * Calculates which objects from a table, collection, or view match a string
 * expression for the given string columns. The options 'case_sensitive' can be
 * used to modify the behavior for all modes except 'search'. For 'search' mode
 * details and limitations, see <a href="../../concepts/full_text_search.html"
 * target="_top">Full Text Search</a>.
 *
 * @param {String} table_name  Name of the table on which the filter operation
 *                             will be performed.  Must be an existing table,
 *                             collection or view.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results. Has the same naming
 *                            restrictions as <a
 *                            href="../../concepts/tables.html"
 *                            target="_top">tables</a>.
 * @param {String} expression  The expression with which to filter the table.
 * @param {String} mode  The string filtering mode to apply. See below for
 *                       details. Values: search, equals, contains,
 *                       starts_with, regex.
 * @param {String[]} column_names  List of columns on which to apply the
 *                                 filter. Ignored for 'search' mode.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> case_sensitive: If 'false' then string
 *                          filtering will ignore case. Does not apply to
 *                          'search' mode. Values: true, false.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_string = function(table_name, view_name, expression, mode, column_names, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_string(table_name, view_name, expression, mode, column_names, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        expression: expression,
        mode: mode,
        column_names: column_names,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/bystring", actual_request, callback);
};

/**
 * Filters objects in one table based on objects in another table. The user
 * must specify matching column types from the two tables (i.e. the target
 * table from which objects will be filtered and the source table based on
 * which the filter will be created); the column names need not be the same. If
 * a <code>view_name</code> is specified, then the filtered objects will then
 * be put in a newly created view. The operation is synchronous, meaning that a
 * response will not be returned until all objects are fully available in the
 * result view. The return value contains the count (i.e. the size) of the
 * resulting view.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        column_name: request.column_name,
        source_table_name: request.source_table_name,
        source_table_column_name: request.source_table_column_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/bytable", actual_request, callback);
};

/**
 * Filters objects in one table based on objects in another table. The user
 * must specify matching column types from the two tables (i.e. the target
 * table from which objects will be filtered and the source table based on
 * which the filter will be created); the column names need not be the same. If
 * a <code>view_name</code> is specified, then the filtered objects will then
 * be put in a newly created view. The operation is synchronous, meaning that a
 * response will not be returned until all objects are fully available in the
 * result view. The return value contains the count (i.e. the size) of the
 * resulting view.
 *
 * @param {String} table_name  Name of the table whose data will be filtered.
 *                             Must be an existing table.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results. Has the same naming
 *                            restrictions as <a
 *                            href="../../concepts/tables.html"
 *                            target="_top">tables</a>.
 * @param {String} column_name  Name of the column by whose value the data will
 *                              be filtered from the table designated by
 *                              <code>table_name</code>.
 * @param {String} source_table_name  Name of the table whose data will be
 *                                    compared against in the table called
 *                                    <code>table_name</code>. Must be an
 *                                    existing table.
 * @param {String} source_table_column_name  Name of the column in the
 *                                           <code>source_table_name</code>
 *                                           whose values will be used as the
 *                                           filter for table
 *                                           <code>table_name</code>. Must
 *                                           match the type of the
 *                                           <code>column_name</code>.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> filter_mode: String indicating the
 *                          filter mode, either <code>in_table</code> or
 *                          <code>not_in_table</code>.
 *                                  <li> mode: Mode - should be either
 *                          <code>spatial</code> or <code>normal</code>.
 *                                  <li> buffer: Buffer size, in meters. Only
 *                          relevant for <code>spatial</code> mode.
 *                                  <li> buffer_method: Method used to buffer
 *                          polygons.  Only relevant for <code>spatial</code>
 *                          mode.
 *                                  <li> max_partition_size: Maximum number of
 *                          points in a partition. Only relevant for
 *                          <code>spatial</code> mode.
 *                                  <li> max_partition_score: Maximum number of
 *                          points * edges in a partition. Only relevant for
 *                          <code>spatial</code> mode.
 *                                  <li> x_column_name: Name of column
 *                          containing x value of point being filtered in
 *                          <code>spatial</code> mode.
 *                                  <li> y_column_name: Name of column
 *                          containing y value of point being filtered in
 *                          <code>spatial</code> mode.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_table = function(table_name, view_name, column_name, source_table_name, source_table_column_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_table(table_name, view_name, column_name, source_table_name, source_table_column_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        column_name: column_name,
        source_table_name: source_table_name,
        source_table_column_name: source_table_column_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/bytable", actual_request, callback);
};

/**
 * Calculates which objects from a table has a particular value for a
 * particular column. The input parameters provide a way to specify either a
 * String or a Double valued column and a desired value for the column on which
 * the filter is performed. The operation is synchronous, meaning that a
 * response will not be returned until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new result view
 * which satisfies the input filter restriction specification is also created
 * with a view name passed in as part of the input payload.  Although this
 * functionality can also be accomplished with the standard filter function, it
 * is more efficient.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_value_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_value_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        is_string: request.is_string,
        value: (request.value !== undefined && request.value !== null) ? request.value : 0,
        value_str: (request.value_str !== undefined && request.value_str !== null) ? request.value_str : "",
        column_name: request.column_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/byvalue", actual_request, callback);
};

/**
 * Calculates which objects from a table has a particular value for a
 * particular column. The input parameters provide a way to specify either a
 * String or a Double valued column and a desired value for the column on which
 * the filter is performed. The operation is synchronous, meaning that a
 * response will not be returned until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new result view
 * which satisfies the input filter restriction specification is also created
 * with a view name passed in as part of the input payload.  Although this
 * functionality can also be accomplished with the standard filter function, it
 * is more efficient.
 *
 * @param {String} table_name  Name of an existing table on which to perform
 *                             the calculation.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results. Has the same naming
 *                            restrictions as <a
 *                            href="../../concepts/tables.html"
 *                            target="_top">tables</a>.
 * @param {Boolean} is_string  Indicates whether the value being searched for
 *                             is string or numeric.
 * @param {Number} value  The value to search for.
 * @param {String} value_str  The string value to search for.
 * @param {String} column_name  Name of a column on which the filter by value
 *                              would be applied.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_value = function(table_name, view_name, is_string, value, value_str, column_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_value(table_name, view_name, is_string, value, value_str, column_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        is_string: is_string,
        value: (value !== undefined && value !== null) ? value : 0,
        value_str: (value_str !== undefined && value_str !== null) ? value_str : "",
        column_name: column_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/byvalue", actual_request, callback);
};

/**
 * Retrieves records from a given table, optionally filtered by an expression
 * and/or sorted by a column. This operation can be performed on tables, views,
 * or on homogeneous collections (collections containing tables of all the same
 * type). Records can be returned encoded as binary or json.
 * <p>
 * This operation supports paging through the data via the <code>offset</code>
 * and <code>limit</code> parameters. Note that when paging through a table, if
 * the table (or the underlying table in case of a view) is updated (records
 * are inserted, deleted or modified) the records retrieved may differ between
 * calls based on the updates applied.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.get_records_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_records_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        offset: (request.offset !== undefined && request.offset !== null) ? request.offset : 0,
        limit: (request.limit !== undefined && request.limit !== null) ? request.limit : 10000,
        encoding: (request.encoding !== undefined && request.encoding !== null) ? request.encoding : "json",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/get/records", actual_request, function(err, data) {
        if (err === null) {
            data.data = GPUdb.decode(data.records_json);
            delete data.records_json;
        }

        callback(err, data);
    });
};

/**
 * Retrieves records from a given table, optionally filtered by an expression
 * and/or sorted by a column. This operation can be performed on tables, views,
 * or on homogeneous collections (collections containing tables of all the same
 * type). Records can be returned encoded as binary or json.
 * <p>
 * This operation supports paging through the data via the <code>offset</code>
 * and <code>limit</code> parameters. Note that when paging through a table, if
 * the table (or the underlying table in case of a view) is updated (records
 * are inserted, deleted or modified) the records retrieved may differ between
 * calls based on the updates applied.
 *
 * @param {String} table_name  Name of the table from which the records will be
 *                             fetched. Must be a table, view or homogeneous
 *                             collection.
 * @param {Number} offset  A positive integer indicating the number of initial
 *                         results to skip (this can be useful for paging
 *                         through the results).
 * @param {Number} limit  A positive integer indicating the maximum number of
 *                        results to be returned. Or END_OF_SET (-9999) to
 *                        indicate that the max number of results should be
 *                        returned.
 * @param {Object} options
 *                          <ul>
 *                                  <li> expression: Optional filter expression
 *                          to apply to the table.
 *                                  <li> fast_index_lookup: Indicates if
 *                          indexes should be used to perform the lookup for a
 *                          given expression if possible. Only applicable if
 *                          there is no sorting, the expression contains only
 *                          equivalence comparisons based on existing tables
 *                          indexes and the range of requested values is from
 *                          [0 to END_OF_SET]. The default value is true.
 *                                  <li> sort_by: Optional column that the data
 *                          should be sorted by. Empty by default (i.e. no
 *                          sorting is applied).
 *                                  <li> sort_order: String indicating how the
 *                          returned values should be sorted - ascending or
 *                          descending. If sort_order is provided, sort_by has
 *                          to be provided. Values: ascending, descending.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.get_records = function(table_name, offset, limit, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_records(table_name, offset, limit, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        offset: (offset !== undefined && offset !== null) ? offset : 0,
        limit: (limit !== undefined && limit !== null) ? limit : 10000,
        encoding: "json",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/get/records", actual_request, function(err, data) {
        if (err === null) {
            data.data = GPUdb.decode(data.records_json);
            delete data.records_json;
        }

        callback(err, data);
    });
};

/**
 * For a given table, retrieves the values of the given columns within a given
 * range. It returns maps of column name to the vector of values for each
 * supported data type (double, float, long, int and string). This operation
 * supports pagination feature, i.e. values that are retrieved are those
 * associated with the indices between the start (offset) and end value (offset
 * + limit) parameters (inclusive). If there are num_points values in the table
 * then each of the indices between 0 and num_points-1 retrieves a unique
 * value.
 * <p>
 * Note that when using the pagination feature, if the table (or the underlying
 * table in case of a view) is updated (records are inserted, deleted or
 * modified) the records or values retrieved may differ between calls
 * (discontiguous or overlap) based on the type of the update.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/dynamic_schemas.html" target="_top">dynamic schemas
 * documentation</a>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.get_records_by_column_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_records_by_column_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        column_names: request.column_names,
        offset: request.offset,
        limit: request.limit,
        encoding: (request.encoding !== undefined && request.encoding !== null) ? request.encoding : "json",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/get/records/bycolumn", actual_request, function(err, data) {
        if (err === null) {
            data.data = GPUdb.decode(data.json_encoded_response);
            delete data.json_encoded_response;
        }

        callback(err, data);
    });
};

/**
 * For a given table, retrieves the values of the given columns within a given
 * range. It returns maps of column name to the vector of values for each
 * supported data type (double, float, long, int and string). This operation
 * supports pagination feature, i.e. values that are retrieved are those
 * associated with the indices between the start (offset) and end value (offset
 * + limit) parameters (inclusive). If there are num_points values in the table
 * then each of the indices between 0 and num_points-1 retrieves a unique
 * value.
 * <p>
 * Note that when using the pagination feature, if the table (or the underlying
 * table in case of a view) is updated (records are inserted, deleted or
 * modified) the records or values retrieved may differ between calls
 * (discontiguous or overlap) based on the type of the update.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/dynamic_schemas.html" target="_top">dynamic schemas
 * documentation</a>.
 *
 * @param {String} table_name  Name of the table on which this operation will
 *                             be performed. The table cannot be a parent set.
 * @param {String[]} column_names  The list of column values to retrieve.
 * @param {Number} offset  A positive integer indicating the number of initial
 *                         results to skip (this can be useful for paging
 *                         through the results).
 * @param {Number} limit  A positive integer indicating the maximum number of
 *                        results to be returned (if not provided the default
 *                        is 10000), or END_OF_SET (-9999) to indicate that the
 *                        maximum number of results allowed by the server
 *                        should be returned.
 * @param {Object} options
 *                          <ul>
 *                                  <li> expression: Optional filter expression
 *                          to apply to the table.
 *                                  <li> sort_by: Optional column that the data
 *                          should be sorted by. Empty by default (i.e. no
 *                          sorting is applied).
 *                                  <li> sort_order: String indicating how the
 *                          returned values should be sorted - ascending or
 *                          descending. Default is 'ascending'. If sort_order
 *                          is provided, sort_by has to be provided. Values:
 *                          ascending, descending.
 *                                  <li> order_by: Comma-separated list of the
 *                          columns to be sorted by; e.g. 'timestamp asc, x
 *                          desc'.  The columns specified must be present in
 *                          <code>column_names</code>.  If any alias is given
 *                          for any column name, the alias must be used, rather
 *                          than the original column name.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.get_records_by_column = function(table_name, column_names, offset, limit, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_records_by_column(table_name, column_names, offset, limit, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        column_names: column_names,
        offset: offset,
        limit: limit,
        encoding: "json",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/get/records/bycolumn", actual_request, function(err, data) {
        if (err === null) {
            data.data = GPUdb.decode(data.json_encoded_response);
            delete data.json_encoded_response;
        }

        callback(err, data);
    });
};

/**
 * Retrieves the complete series/track records from the given
 * <code>world_table_name</code> based on the partial track information
 * contained in the <code>table_name</code>.
 * <p>
 * This operation supports paging through the data via the <code>offset</code>
 * and <code>limit</code> parameters.
 * <p>
 * In contrast to {@linkcode GPUdb#get_records} this returns records grouped
 * by series/track. So if <code>offset</code> is 0 and <code>limit</code> is 5
 * this operation would return the first 5 series/tracks in
 * <code>table_name</code>. Each series/track will be returned sorted by their
 * TIMESTAMP column.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.get_records_by_series_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_records_by_series_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        world_table_name: request.world_table_name,
        offset: (request.offset !== undefined && request.offset !== null) ? request.offset : 0,
        limit: (request.limit !== undefined && request.limit !== null) ? request.limit : 10000,
        encoding: (request.encoding !== undefined && request.encoding !== null) ? request.encoding : "json",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/get/records/byseries", actual_request, function(err, data) {
        if (err === null) {
            data.data = GPUdb.decode(data.list_records_json);
            delete data.list_records_json;
        }

        callback(err, data);
    });
};

/**
 * Retrieves the complete series/track records from the given
 * <code>world_table_name</code> based on the partial track information
 * contained in the <code>table_name</code>.
 * <p>
 * This operation supports paging through the data via the <code>offset</code>
 * and <code>limit</code> parameters.
 * <p>
 * In contrast to {@linkcode GPUdb#get_records} this returns records grouped
 * by series/track. So if <code>offset</code> is 0 and <code>limit</code> is 5
 * this operation would return the first 5 series/tracks in
 * <code>table_name</code>. Each series/track will be returned sorted by their
 * TIMESTAMP column.
 *
 * @param {String} table_name  Name of the collection/table/view for which
 *                             series/tracks will be fetched.
 * @param {String} world_table_name  Name of the table containing the complete
 *                                   series/track information to be returned
 *                                   for the tracks present in the
 *                                   <code>table_name</code>. Typically this is
 *                                   used when retrieving series/tracks from a
 *                                   view (which contains partial
 *                                   series/tracks) but the user wants to
 *                                   retrieve the entire original
 *                                   series/tracks. Can be blank.
 * @param {Number} offset  A positive integer indicating the number of initial
 *                         series/tracks to skip (useful for paging through the
 *                         results).
 * @param {Number} limit  A positive integer indicating the maximum number of
 *                        series/tracks to be returned. Or END_OF_SET (-9999)
 *                        to indicate that the max number of results should be
 *                        returned.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.get_records_by_series = function(table_name, world_table_name, offset, limit, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_records_by_series(table_name, world_table_name, offset, limit, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        world_table_name: world_table_name,
        offset: (offset !== undefined && offset !== null) ? offset : 0,
        limit: (limit !== undefined && limit !== null) ? limit : 10000,
        encoding: "json",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/get/records/byseries", actual_request, function(err, data) {
        if (err === null) {
            data.data = GPUdb.decode(data.list_records_json);
            delete data.list_records_json;
        }

        callback(err, data);
    });
};

/**
 * Retrieves records from a collection. The operation can optionally return the
 * record IDs which can be used in certain queries such as
 * {@linkcode GPUdb#delete_records}.
 * <p>
 * This operation supports paging through the data via the <code>offset</code>
 * and <code>limit</code> parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.get_records_from_collection_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_records_from_collection_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        offset: (request.offset !== undefined && request.offset !== null) ? request.offset : 0,
        limit: (request.limit !== undefined && request.limit !== null) ? request.limit : 10000,
        encoding: (request.encoding !== undefined && request.encoding !== null) ? request.encoding : "json",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/get/records/fromcollection", actual_request, function(err, data) {
        if (err === null) {
            data.data = GPUdb.decode(data.records_json);
            delete data.records_json;
        }

        callback(err, data);
    });
};

/**
 * Retrieves records from a collection. The operation can optionally return the
 * record IDs which can be used in certain queries such as
 * {@linkcode GPUdb#delete_records}.
 * <p>
 * This operation supports paging through the data via the <code>offset</code>
 * and <code>limit</code> parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 *
 * @param {String} table_name  Name of the collection or table from which
 *                             records are to be retrieved. Must be an existing
 *                             collection or table.
 * @param {Number} offset  A positive integer indicating the number of initial
 *                         results to skip (this can be useful for paging
 *                         through the results).
 * @param {Number} limit  A positive integer indicating the maximum number of
 *                        results to be returned, or END_OF_SET (-9999) to
 *                        indicate that the max number of results should be
 *                        returned.
 * @param {Object} options
 *                          <ul>
 *                                  <li> return_record_ids: If 'true' then
 *                          return the internal record ID along with each
 *                          returned record. Default is 'false'. Values: true,
 *                          false.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.get_records_from_collection = function(table_name, offset, limit, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_records_from_collection(table_name, offset, limit, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        offset: (offset !== undefined && offset !== null) ? offset : 0,
        limit: (limit !== undefined && limit !== null) ? limit : 10000,
        encoding: "json",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/get/records/fromcollection", actual_request, function(err, data) {
        if (err === null) {
            data.data = GPUdb.decode(data.records_json);
            delete data.records_json;
        }

        callback(err, data);
    });
};

/**
 * Grants a system-level permission to a user or role.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.grant_permission_system_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.grant_permission_system_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        permission: request.permission,
        options: request.options
    };

    this.submit_request("/grant/permission/system", actual_request, callback);
};

/**
 * Grants a system-level permission to a user or role.
 *
 * @param {String} name  Name of the user or role to which the permission will
 *                       be granted. Must be an existing user or role.
 * @param {String} permission  Permission to grant to the user or role. Values:
 *                             system_admin, system_write, system_read.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.grant_permission_system = function(name, permission, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.grant_permission_system(name, permission, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        permission: permission,
        options: options
    };

    this.submit_request("/grant/permission/system", actual_request, callback);
};

/**
 * Grants a table-level permission to a user or role.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.grant_permission_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.grant_permission_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        permission: request.permission,
        table_name: request.table_name,
        filter_expression: (request.filter_expression !== undefined && request.filter_expression !== null) ? request.filter_expression : "",
        options: request.options
    };

    this.submit_request("/grant/permission/table", actual_request, callback);
};

/**
 * Grants a table-level permission to a user or role.
 *
 * @param {String} name  Name of the user or role to which the permission will
 *                       be granted. Must be an existing user or role.
 * @param {String} permission  Permission to grant to the user or role. Values:
 *                             table_admin, table_insert, table_update,
 *                             table_delete, table_read.
 * @param {String} table_name  Name of the table to which the permission grants
 *                             access. Must be an existing table, collection,
 *                             or view. If a collection, the permission also
 *                             applies to tables and views in the collection.
 * @param {String} filter_expression  Reserved for future use.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.grant_permission_table = function(name, permission, table_name, filter_expression, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.grant_permission_table(name, permission, table_name, filter_expression, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        permission: permission,
        table_name: table_name,
        filter_expression: (filter_expression !== undefined && filter_expression !== null) ? filter_expression : "",
        options: options
    };

    this.submit_request("/grant/permission/table", actual_request, callback);
};

/**
 * Grants membership in a role to a user or role.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.grant_role_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.grant_role_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        role: request.role,
        member: request.member,
        options: request.options
    };

    this.submit_request("/grant/role", actual_request, callback);
};

/**
 * Grants membership in a role to a user or role.
 *
 * @param {String} role  Name of the role in which membership will be granted.
 *                       Must be an existing role.
 * @param {String} member  Name of the user or role that will be granted
 *                         membership in <code>role</code>. Must be an existing
 *                         user or role.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.grant_role = function(role, member, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.grant_role(role, member, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        role: role,
        member: member,
        options: options
    };

    this.submit_request("/grant/role", actual_request, callback);
};

/**
 * Checks the existence of a proc with the given name.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.has_proc_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.has_proc_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        proc_name: request.proc_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/has/proc", actual_request, callback);
};

/**
 * Checks the existence of a proc with the given name.
 *
 * @param {String} proc_name  Name of the proc to check for existence.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.has_proc = function(proc_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.has_proc(proc_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        proc_name: proc_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/has/proc", actual_request, callback);
};

/**
 * Checks for the existence of a table with the given name.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.has_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.has_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/has/table", actual_request, callback);
};

/**
 * Checks for the existence of a table with the given name.
 *
 * @param {String} table_name  Name of the table to check for existence.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.has_table = function(table_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.has_table(table_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/has/table", actual_request, callback);
};

/**
 * Check for the existence of a type.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.has_type_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.has_type_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        type_id: request.type_id,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/has/type", actual_request, callback);
};

/**
 * Check for the existence of a type.
 *
 * @param {String} type_id  Id of the type returned in response to
 *                          {@linkcode GPUdb#create_type} request.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.has_type = function(type_id, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.has_type(type_id, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        type_id: type_id,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/has/type", actual_request, callback);
};

/**
 * Adds multiple records to the specified table. The operation is synchronous,
 * meaning that a response will not be returned until all the records are fully
 * inserted and available. The response payload provides the counts of the
 * number of records actually inserted and/or updated, and can provide the
 * unique identifier of each added record.
 * <p>
 * The <code>options</code> parameter can be used to customize this function's
 * behavior.  The <code>update_on_existing_pk</code> option specifies the
 * primary-key collision policy.  If the table has a
 * [primary key]{@linkcode GPUdb#create_type} and if
 * <code>update_on_existing_pk</code> is <code>true</code>, then if any of the
 * records being added have the same primary key as existing records, the
 * existing records are replaced (i.e. updated) with the given records.  If
 * <code>update_on_existing_pk</code> is <code>false</code> and if the records
 * being added have the same primary key as existing records, they are ignored
 * (the existing records are left unchanged).  It is quite possible that in
 * this case some of the given records will be inserted and some (those having
 * existing primary keys) will be ignored (or updated).  If the specified table
 * does not have a primary key column, then the
 * <code>update_on_existing_pk</code> option is ignored.
 * <p>
 * The <code>return_record_ids</code> option indicates that the database should
 * return the unique identifiers of inserted records.
 * <p>
 * The <code>route_to_address</code> option directs that inserted records
 * should be targeted for a particular database node.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.insert_records_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.insert_records_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        list: (request.list !== undefined && request.list !== null) ? request.list : [],
        list_str: (request.data !== undefined && request.data !== null) ? GPUdb.encode(request.data) : [],
        list_encoding: (request.list_encoding !== undefined && request.list_encoding !== null) ? request.list_encoding : "json",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/insert/records", actual_request, callback);
};

/**
 * Adds multiple records to the specified table. The operation is synchronous,
 * meaning that a response will not be returned until all the records are fully
 * inserted and available. The response payload provides the counts of the
 * number of records actually inserted and/or updated, and can provide the
 * unique identifier of each added record.
 * <p>
 * The <code>options</code> parameter can be used to customize this function's
 * behavior.  The <code>update_on_existing_pk</code> option specifies the
 * primary-key collision policy.  If the table has a
 * [primary key]{@linkcode GPUdb#create_type} and if
 * <code>update_on_existing_pk</code> is <code>true</code>, then if any of the
 * records being added have the same primary key as existing records, the
 * existing records are replaced (i.e. updated) with the given records.  If
 * <code>update_on_existing_pk</code> is <code>false</code> and if the records
 * being added have the same primary key as existing records, they are ignored
 * (the existing records are left unchanged).  It is quite possible that in
 * this case some of the given records will be inserted and some (those having
 * existing primary keys) will be ignored (or updated).  If the specified table
 * does not have a primary key column, then the
 * <code>update_on_existing_pk</code> option is ignored.
 * <p>
 * The <code>return_record_ids</code> option indicates that the database should
 * return the unique identifiers of inserted records.
 * <p>
 * The <code>route_to_address</code> option directs that inserted records
 * should be targeted for a particular database node.
 *
 * @param {String} table_name  Table to which the records are to be added. Must
 *                             be an existing table.
 * @param {Object[]} data  An array of JSON encoded data for the records to be
 *                         added. All records must be of the same type as that
 *                         of the table. Empty array if
 *                         <code>list_encoding</code> is <code>binary</code>.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> update_on_existing_pk: If the table
 *                          has a
 *                          [primary key]{@linkcode GPUdb#create_type},
 *                          then if the value is <code>true</code> then if any
 *                          of the records being added have the same primary
 *                          key as existing records, the existing records are
 *                          replaced (i.e. updated) with the given records. If
 *                          <code>false</code>, and if the records being added
 *                          have the same primary key as existing records, they
 *                          are ignored (the existing records are left
 *                          unchanged).  It is quite possible that in this case
 *                          some of the given records will be inserted and some
 *                          (those having existing primary keys) will be
 *                          ignored (or updated). If the specified table does
 *                          not have a primary key column then this optional
 *                          parameter is ignored. Values: true, false.
 *                                  <li> return_record_ids: If
 *                          <code>true</code> then return the internal record
 *                          id along for each inserted record. Values: true,
 *                          false.
 *                                  <li> route_to_address: Route to a specific
 *                          rank/tom. Option not suitable for tables using
 *                          primary/shard keys
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.insert_records = function(table_name, data, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.insert_records(table_name, data, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        list: [],
        list_str: GPUdb.encode(data),
        list_encoding: "json",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/insert/records", actual_request, callback);
};

/**
 * Generates a specified number of random records and adds them to the given
 * table. There is an optional parameter that allows the user to customize the
 * ranges of the column values. It also allows the user to specify linear
 * profiles for some or all columns in which case linear values are generated
 * rather than random ones. Only individual tables are supported for this
 * operation.
 * <p>
 * This operation is synchronous, meaning that a response will not be returned
 * until all random records are fully available.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.insert_records_random_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.insert_records_random_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        count: request.count,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/insert/records/random", actual_request, callback);
};

/**
 * Generates a specified number of random records and adds them to the given
 * table. There is an optional parameter that allows the user to customize the
 * ranges of the column values. It also allows the user to specify linear
 * profiles for some or all columns in which case linear values are generated
 * rather than random ones. Only individual tables are supported for this
 * operation.
 * <p>
 * This operation is synchronous, meaning that a response will not be returned
 * until all random records are fully available.
 *
 * @param {String} table_name  Table to which random records will be added.
 *                             Must be an existing table.  Also, must be an
 *                             individual table, not a collection of tables,
 *                             nor a view of a table.
 * @param {Number} count  Number of records to generate.
 * @param {Object} options  Optional parameter to pass in specifications for
 *                          the randomness of the values.  This map is
 *                          different from the *options* parameter of most
 *                          other endpoints in that it is a map of string to
 *                          map of string to doubles, while most others are
 *                          maps of string to string.  In this map, the top
 *                          level keys represent which column's parameters are
 *                          being specified, while the internal keys represents
 *                          which parameter is being specified.  The parameters
 *                          that can be specified are: *min*, *max*, and
 *                          *interval*.  These parameters take on different
 *                          meanings depending on the type of the column.
 *                          Below follows a more detailed description of the
 *                          map:
 *                          <ul>
 *                                  <li> seed: If provided, the internal random
 *                          number generator will be initialized with the given
 *                          value.  The minimum is 0.  This allows for the same
 *                          set of random numbers to be generated across
 *                          invocation of this endpoint in case the user wants
 *                          to repeat the test.  Since <code>options</code>, is
 *                          a map of maps, we need an internal map to provide
 *                          the seed value.  For example, to pass 100 as the
 *                          seed value through this parameter, you need
 *                          something equivalent to: 'options' = {'seed': {
 *                          'value': 100 } }
 *                          <ul>
 *                                  <li> value: Pass the seed value here.
 *                          </ul>
 *                                  <li> all: This key indicates that the
 *                          specifications relayed in the internal map are to
 *                          be applied to all columns of the records.
 *                          <ul>
 *                                  <li> min: For numerical columns, the
 *                          minimum of the generated values is set to this
 *                          value.  Default is -99999.  For point, shape, and
 *                          track semantic types, min for numeric 'x' and 'y'
 *                          columns needs to be within [-180, 180] and [-90,
 *                          90], respectively. The default minimum possible
 *                          values for these columns in such cases are -180.0
 *                          and -90.0. For the 'TIMESTAMP' column, the default
 *                          minimum corresponds to Jan 1, 2010.
 *                          For string columns, the minimum length of the
 *                          randomly generated strings is set to this value
 *                          (default is 1). If both minimum and maximum are
 *                          provided, minimum must be less than or equal to
 *                          max. Value needs to be within [1, 200].
 *                          If the min is outside the accepted ranges for
 *                          strings columns and 'x' and 'y' columns for
 *                          point/shape/track types, then those parameters will
 *                          not be set; however, an error will not be thrown in
 *                          such a case. It is the responsibility of the user
 *                          to use the <code>all</code> parameter judiciously.
 *                                  <li> max: For numerical columns, the
 *                          maximum of the generated values is set to this
 *                          value. Default is 99999. For point, shape, and
 *                          track semantic types, max for numeric 'x' and 'y'
 *                          columns needs to be within [-180, 180] and [-90,
 *                          90], respectively. The default minimum possible
 *                          values for these columns in such cases are 180.0
 *                          and 90.0.
 *                          For string columns, the maximum length of the
 *                          randomly generated strings is set to this value
 *                          (default is 200). If both minimum and maximum are
 *                          provided, *max* must be greater than or equal to
 *                          *min*. Value needs to be within [1, 200].
 *                          If the *max* is outside the accepted ranges for
 *                          strings columns and 'x' and 'y' columns for
 *                          point/shape/track types, then those parameters will
 *                          not be set; however, an error will not be thrown in
 *                          such a case. It is the responsibility of the user
 *                          to use the <code>all</code> parameter judiciously.
 *                                  <li> interval: If specified, then generate
 *                          values for all columns linearly and evenly spaced
 *                          with the given interval value starting at the
 *                          minimum value (instead of generating random data).
 *                          *Any provided max value is disregarded.*  For
 *                          string-type columns, the interval value is ignored
 *                          but the string values would be generated following
 *                          the pattern: 'attrname_creationIndex#', i.e. the
 *                          column name suffixed with an underscore and a
 *                          running counter (starting at 0).  No nulls would be
 *                          generated for nullable columns.
 *                                  <li> null_percentage: If specified, then
 *                          generate the given percentage of the count as nulls
 *                          for all nullable columns.  This option will be
 *                          ignored for non-nullable columns.  The value must
 *                          be within the range [0, 1.0].  The default value is
 *                          5% (0.05).
 *                          </ul>
 *                                  <li> attr_name: Set the following
 *                          parameters for the column specified by the key.
 *                          This overrides any parameter set by
 *                          <code>all</code>.
 *                          <ul>
 *                                  <li> min: For numerical columns, the
 *                          minimum of the generated values is set to this
 *                          value.  Default is -99999.  For point, shape, and
 *                          track semantic types, min for numeric 'x' and 'y'
 *                          columns needs to be within [-180, 180] and [-90,
 *                          90], respectively. The default minimum possible
 *                          values for these columns in such cases are -180.0
 *                          and -90.0. For the 'TIMESTAMP' column, the default
 *                          minimum corresponds to Jan 1, 2010.
 *                          For string columns, the minimum length of the
 *                          randomly generated strings is set to this value
 *                          (default is 1). If both minimum and maximum are
 *                          provided, minimum must be less than or equal to
 *                          max. Value needs to be within [1, 200].
 *                          If the min is outside the accepted ranges for
 *                          strings columns and 'x' and 'y' columns for
 *                          point/shape/track types, then those parameters will
 *                          not be set; however, an error will not be thrown in
 *                          such a case. It is the responsibility of the user
 *                          to use the <code>all</code> parameter judiciously.
 *                                  <li> max: For numerical columns, the
 *                          maximum of the generated values is set to this
 *                          value. Default is 99999. For point, shape, and
 *                          track semantic types, max for numeric 'x' and 'y'
 *                          columns needs to be within [-180, 180] and [-90,
 *                          90], respectively. The default minimum possible
 *                          values for these columns in such cases are 180.0
 *                          and 90.0.
 *                          For string columns, the maximum length of the
 *                          randomly generated strings is set to this value
 *                          (default is 200). If both minimum and maximum are
 *                          provided, *max* must be greater than or equal to
 *                          *min*. Value needs to be within [1, 200].
 *                          If the *max* is outside the accepted ranges for
 *                          strings columns and 'x' and 'y' columns for
 *                          point/shape/track types, then those parameters will
 *                          not be set; however, an error will not be thrown in
 *                          such a case. It is the responsibility of the user
 *                          to use the <code>all</code> parameter judiciously.
 *                                  <li> interval: If specified, then generate
 *                          values for all columns linearly and evenly spaced
 *                          with the given interval value starting at the
 *                          minimum value (instead of generating random data).
 *                          *Any provided max value is disregarded.*  For
 *                          string-type columns, the interval value is ignored
 *                          but the string values would be generated following
 *                          the pattern: 'attrname_creationIndex#', i.e. the
 *                          column name suffixed with an underscore and a
 *                          running counter (starting at 0).  No nulls would be
 *                          generated for nullable columns.
 *                                  <li> null_percentage: If specified and if
 *                          this column is nullable, then generate the given
 *                          percentage of the count as nulls.  This option will
 *                          result in an error if the column is not nullable.
 *                          The value must be within the range [0, 1.0].  The
 *                          default value is 5% (0.05).
 *                          </ul>
 *                                  <li> track_length: This key-map pair is
 *                          only valid for track type data sets (an error is
 *                          thrown otherwise).  No nulls would be generated for
 *                          nullable columns.
 *                          <ul>
 *                                  <li> min: Minimum possible length for
 *                          generated series; default is 100 records per
 *                          series. Must be an integral value within the range
 *                          [1, 500]. If both min and max are specified, min
 *                          must be less than or equal to max.
 *                                  <li> max: Maximum possible length for
 *                          generated series; default is 500 records per
 *                          series. Must be an integral value within the range
 *                          [1, 500]. If both min and max are specified, max
 *                          must be greater than or equal to min.
 *                          </ul>
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.insert_records_random = function(table_name, count, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.insert_records_random(table_name, count, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        count: count,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/insert/records/random", actual_request, callback);
};

/**
 * Adds a symbol or icon (i.e. an image) to represent data points when data is
 * rendered visually. Users must provide the symbol identifier (string), a
 * format (currently supported: 'svg' and 'svg_path'), the data for the symbol,
 * and any additional optional parameter (e.g. color). To have a symbol used
 * for rendering create a table with a string column named 'SYMBOLCODE' (along
 * with 'x' or 'y' for example). Then when the table is rendered (via <a
 * href="../../api/rest/wms_rest.html" target="_top">WMS</a>) if the
 * 'dosymbology' parameter is 'true' then the value of the 'SYMBOLCODE' column
 * is used to pick the symbol displayed for each point.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.insert_symbol_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.insert_symbol_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        symbol_id: request.symbol_id,
        symbol_format: request.symbol_format,
        symbol_data: request.symbol_data,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/insert/symbol", actual_request, callback);
};

/**
 * Adds a symbol or icon (i.e. an image) to represent data points when data is
 * rendered visually. Users must provide the symbol identifier (string), a
 * format (currently supported: 'svg' and 'svg_path'), the data for the symbol,
 * and any additional optional parameter (e.g. color). To have a symbol used
 * for rendering create a table with a string column named 'SYMBOLCODE' (along
 * with 'x' or 'y' for example). Then when the table is rendered (via <a
 * href="../../api/rest/wms_rest.html" target="_top">WMS</a>) if the
 * 'dosymbology' parameter is 'true' then the value of the 'SYMBOLCODE' column
 * is used to pick the symbol displayed for each point.
 *
 * @param {String} symbol_id  The id of the symbol being added. This is the
 *                            same id that should be in the 'SYMBOLCODE' column
 *                            for objects using this symbol
 * @param {String} symbol_format  Specifies the symbol format. Must be either
 *                                'svg' or 'svg_path'. Values: svg, svg_path.
 * @param {String} symbol_data  The actual symbol data. If
 *                              <code>symbol_format</code> is 'svg' then this
 *                              should be the raw bytes representing an svg
 *                              file. If <code>symbol_format</code> is svg path
 *                              then this should be an svg path string, for
 *                              example:
 *                              'M25.979,12.896,5.979,12.896,5.979,19.562,25.979,19.562z'
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> color: If <code>symbol_format</code>
 *                          is 'svg' this is ignored. If
 *                          <code>symbol_format</code> is 'svg_path' then this
 *                          option specifies the color (in RRGGBB hex format)
 *                          of the path. For example, to have the path rendered
 *                          in red, used 'FF0000'. If 'color' is not provided
 *                          then '00FF00' (i.e. green) is used by default.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.insert_symbol = function(symbol_id, symbol_format, symbol_data, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.insert_symbol(symbol_id, symbol_format, symbol_data, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        symbol_id: symbol_id,
        symbol_format: symbol_format,
        symbol_data: symbol_data,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/insert/symbol", actual_request, callback);
};

/**
 * Kills a running proc instance.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.kill_proc_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.kill_proc_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        run_id: (request.run_id !== undefined && request.run_id !== null) ? request.run_id : "",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/kill/proc", actual_request, callback);
};

/**
 * Kills a running proc instance.
 *
 * @param {String} run_id  The run ID of the running proc instance. If the run
 *                         ID is not found or the proc instance has already
 *                         completed, this does nothing. If not specified, all
 *                         running proc instances will be killed.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.kill_proc = function(run_id, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.kill_proc(run_id, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        run_id: (run_id !== undefined && run_id !== null) ? run_id : "",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/kill/proc", actual_request, callback);
};

/**
 * Manages global access to a table's data.  By default a table has a
 * <code>lock_type</code> of <code>unlock</code>, indicating all operations are
 * permitted.  A user may request a <code>read-only</code> or a
 * <code>write-only</code> lock, after which only read or write operations,
 * respectively, are permitted on the table until the lock is removed.  When
 * <code>lock_type</code> is <code>disable</code> then no operations are
 * permitted on the table.  The lock status can be queried by setting
 * <code>lock_type</code> to <code>status</code>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.lock_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.lock_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        lock_type: (request.lock_type !== undefined && request.lock_type !== null) ? request.lock_type : "status",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/lock/table", actual_request, callback);
};

/**
 * Manages global access to a table's data.  By default a table has a
 * <code>lock_type</code> of <code>unlock</code>, indicating all operations are
 * permitted.  A user may request a <code>read-only</code> or a
 * <code>write-only</code> lock, after which only read or write operations,
 * respectively, are permitted on the table until the lock is removed.  When
 * <code>lock_type</code> is <code>disable</code> then no operations are
 * permitted on the table.  The lock status can be queried by setting
 * <code>lock_type</code> to <code>status</code>.
 *
 * @param {String} table_name  Name of the table to be locked. It must be a
 *                             currently existing table, collection, or view.
 * @param {String} lock_type  The type of lock being applied to the table.
 *                            Setting it to <code>status</code> will return the
 *                            current lock status of the table without changing
 *                            it. Values: status, disable, read-only,
 *                            write-only, unlock.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.lock_table = function(table_name, lock_type, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.lock_table(table_name, lock_type, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        lock_type: (lock_type !== undefined && lock_type !== null) ? lock_type : "status",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/lock/table", actual_request, callback);
};

/**
 * Revokes a system-level permission from a user or role.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.revoke_permission_system_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.revoke_permission_system_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        permission: request.permission,
        options: request.options
    };

    this.submit_request("/revoke/permission/system", actual_request, callback);
};

/**
 * Revokes a system-level permission from a user or role.
 *
 * @param {String} name  Name of the user or role from which the permission
 *                       will be revoked. Must be an existing user or role.
 * @param {String} permission  Permission to revoke from the user or role.
 *                             Values: system_admin, system_write, system_read.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.revoke_permission_system = function(name, permission, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.revoke_permission_system(name, permission, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        permission: permission,
        options: options
    };

    this.submit_request("/revoke/permission/system", actual_request, callback);
};

/**
 * Revokes a table-level permission from a user or role.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.revoke_permission_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.revoke_permission_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        permission: request.permission,
        table_name: request.table_name,
        options: request.options
    };

    this.submit_request("/revoke/permission/table", actual_request, callback);
};

/**
 * Revokes a table-level permission from a user or role.
 *
 * @param {String} name  Name of the user or role from which the permission
 *                       will be revoked. Must be an existing user or role.
 * @param {String} permission  Permission to revoke from the user or role.
 *                             Values: table_admin, table_insert, table_update,
 *                             table_delete, table_read.
 * @param {String} table_name  Name of the table to which the permission grants
 *                             access. Must be an existing table, collection,
 *                             or view.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.revoke_permission_table = function(name, permission, table_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.revoke_permission_table(name, permission, table_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        permission: permission,
        table_name: table_name,
        options: options
    };

    this.submit_request("/revoke/permission/table", actual_request, callback);
};

/**
 * Revokes membership in a role from a user or role.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.revoke_role_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.revoke_role_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        role: request.role,
        member: request.member,
        options: request.options
    };

    this.submit_request("/revoke/role", actual_request, callback);
};

/**
 * Revokes membership in a role from a user or role.
 *
 * @param {String} role  Name of the role in which membership will be revoked.
 *                       Must be an existing role.
 * @param {String} member  Name of the user or role that will be revoked
 *                         membership in <code>role</code>. Must be an existing
 *                         user or role.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.revoke_role = function(role, member, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.revoke_role(role, member, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        role: role,
        member: member,
        options: options
    };

    this.submit_request("/revoke/role", actual_request, callback);
};

/**
 * Shows information about a proc.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_proc_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_proc_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        proc_name: (request.proc_name !== undefined && request.proc_name !== null) ? request.proc_name : "",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/proc", actual_request, callback);
};

/**
 * Shows information about a proc.
 *
 * @param {String} proc_name  Name of the proc to show information about. If
 *                            specified, must be the name of a currently
 *                            existing proc. If not specified, information
 *                            about all procs will be returned.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> include_files: If set to
 *                          <code>true</code>, the files that make up the proc
 *                          will be returned. If set to <code>false</code>, the
 *                          files will not be returned. Values: true, false.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_proc = function(proc_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_proc(proc_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        proc_name: (proc_name !== undefined && proc_name !== null) ? proc_name : "",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/proc", actual_request, callback);
};

/**
 * Shows the statuses of running or completed proc instances. Results are
 * grouped by run ID (as returned from {@linkcode GPUdb#execute_proc}) and
 * data segment ID (each invocation of the proc command on a data segment is
 * assigned a data segment ID).
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_proc_status_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_proc_status_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        run_id: (request.run_id !== undefined && request.run_id !== null) ? request.run_id : "",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/proc/status", actual_request, callback);
};

/**
 * Shows the statuses of running or completed proc instances. Results are
 * grouped by run ID (as returned from {@linkcode GPUdb#execute_proc}) and
 * data segment ID (each invocation of the proc command on a data segment is
 * assigned a data segment ID).
 *
 * @param {String} run_id  The run ID of a specific running or completed proc
 *                         instance for which the status will be returned. If
 *                         the run ID is not found, nothing will be returned.
 *                         If not specified, the statuses of all running and
 *                         completed proc instances will be returned.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> clear_complete: If set to
 *                          <code>true</code>, if a proc instance has completed
 *                          (either successfully or unsuccessfully) then its
 *                          status will be cleared and no longer returned in
 *                          subsequent calls. Values: true, false.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_proc_status = function(run_id, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_proc_status(run_id, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        run_id: (run_id !== undefined && run_id !== null) ? run_id : "",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/proc/status", actual_request, callback);
};

/**
 * Shows security information relating to users and/or roles. If the caller is
 * not a system administrator, only information relating to the caller and
 * their roles is returned.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_security_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_security_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        names: request.names,
        options: request.options
    };

    this.submit_request("/show/security", actual_request, callback);
};

/**
 * Shows security information relating to users and/or roles. If the caller is
 * not a system administrator, only information relating to the caller and
 * their roles is returned.
 *
 * @param {String[]} names  A list of names of users and/or roles about which
 *                          security information is requested. If none are
 *                          provided, information about all users and roles
 *                          will be returned.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_security = function(names, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_security(names, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        names: names,
        options: options
    };

    this.submit_request("/show/security", actual_request, callback);
};

/**
 * Returns server configuration and version related information to the caller.
 * The admin tool uses it to present server related information to the user.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_system_properties_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_system_properties_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/system/properties", actual_request, callback);
};

/**
 * Returns server configuration and version related information to the caller.
 * The admin tool uses it to present server related information to the user.
 *
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> properties: A list of comma separated
 *                          names of properties requested. If not specified,
 *                          all properties will be returned.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_system_properties = function(options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_system_properties(options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/system/properties", actual_request, callback);
};

/**
 * Provides server configuration and health related status to the caller. The
 * admin tool uses it to present server related information to the user.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_system_status_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_system_status_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/system/status", actual_request, callback);
};

/**
 * Provides server configuration and health related status to the caller. The
 * admin tool uses it to present server related information to the user.
 *
 * @param {Object} options  Optional parameters, currently unused.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_system_status = function(options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_system_status(options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/system/status", actual_request, callback);
};

/**
 * Returns the last 100 database requests along with the request timing and
 * internal job id. The admin tool uses it to present request timing
 * information to the user.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_system_timing_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_system_timing_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/system/timing", actual_request, callback);
};

/**
 * Returns the last 100 database requests along with the request timing and
 * internal job id. The admin tool uses it to present request timing
 * information to the user.
 *
 * @param {Object} options  Optional parameters, currently unused.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_system_timing = function(options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_system_timing(options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/system/timing", actual_request, callback);
};

/**
 * Retrieves detailed information about a table, view, or collection, specified
 * in <code>table_name</code>. If the supplied <code>table_name</code> is a
 * collection, the call can return information about either the collection
 * itself or the tables and views it contains. If <code>table_name</code> is
 * empty, information about all collections and top-level tables and views can
 * be returned.
 * <p>
 * If the option <code>get_sizes</code> is set to <code>true</code>, then the
 * sizes (objects and elements) of each table are returned (in
 * <code>sizes</code> and <code>full_sizes</code>), along with the total number
 * of objects in the requested table (in <code>total_size</code> and
 * <code>total_full_size</code>).
 * <p>
 * For a collection, setting the <code>show_children</code> option to
 * <code>false</code> returns only information about the collection itself;
 * setting <code>show_children</code> to <code>true</code> returns a list of
 * tables and views contained in the collection, along with their description,
 * type id, schema, type label, type properties, and additional information
 * including TTL.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/table", actual_request, callback);
};

/**
 * Retrieves detailed information about a table, view, or collection, specified
 * in <code>table_name</code>. If the supplied <code>table_name</code> is a
 * collection, the call can return information about either the collection
 * itself or the tables and views it contains. If <code>table_name</code> is
 * empty, information about all collections and top-level tables and views can
 * be returned.
 * <p>
 * If the option <code>get_sizes</code> is set to <code>true</code>, then the
 * sizes (objects and elements) of each table are returned (in
 * <code>sizes</code> and <code>full_sizes</code>), along with the total number
 * of objects in the requested table (in <code>total_size</code> and
 * <code>total_full_size</code>).
 * <p>
 * For a collection, setting the <code>show_children</code> option to
 * <code>false</code> returns only information about the collection itself;
 * setting <code>show_children</code> to <code>true</code> returns a list of
 * tables and views contained in the collection, along with their description,
 * type id, schema, type label, type properties, and additional information
 * including TTL.
 *
 * @param {String} table_name  Name of the table for which to retrieve the
 *                             information. If blank, then information about
 *                             all collections and top-level tables and views
 *                             is returned.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> get_sizes: If <code>true</code> then
 *                          the table sizes will be returned; blank, otherwise.
 *                                  <li> show_children: If
 *                          <code>table_name</code> is a collection, then
 *                          <code>true</code> will return information about the
 *                          children of the collection, and <code>false</code>
 *                          will return information about the collection
 *                          itself. If <code>table_name</code> is a table or
 *                          view, <code>show_children</code> must be
 *                          <code>false</code>. If <code>table_name</code> is
 *                          empty, then <code>show_children</code> must be
 *                          <code>true</code>.
 *                                  <li> no_error_if_not_exists: If
 *                          <code>false</code> will return an error if the
 *                          provided <code>table_name</code> does not exist. If
 *                          <code>true</code> then it will return an empty
 *                          result.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_table = function(table_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_table(table_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/table", actual_request, callback);
};

/**
 * Retrieves the user provided metadata for the specified tables.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_table_metadata_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_table_metadata_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: request.table_names,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/table/metadata", actual_request, callback);
};

/**
 * Retrieves the user provided metadata for the specified tables.
 *
 * @param {String[]} table_names  Tables whose metadata will be fetched. All
 *                                provided tables must exist, or an error is
 *                                returned.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_table_metadata = function(table_names, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_table_metadata(table_names, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: table_names,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/table/metadata", actual_request, callback);
};

/**
 * Gets names of the tables whose type matches the given criteria. Each table
 * has a particular type. This type is made out of the type label, schema of
 * the table, and the semantic type of the table. This function allows a look
 * up of the existing tables based on full or partial type information. The
 * operation is synchronous.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_tables_by_type_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_tables_by_type_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        type_id: request.type_id,
        label: request.label,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/tables/bytype", actual_request, callback);
};

/**
 * Gets names of the tables whose type matches the given criteria. Each table
 * has a particular type. This type is made out of the type label, schema of
 * the table, and the semantic type of the table. This function allows a look
 * up of the existing tables based on full or partial type information. The
 * operation is synchronous.
 *
 * @param {String} type_id  Type id returned by a call to
 *                          {@linkcode GPUdb#create_type}.
 * @param {String} label  Optional user supplied label which can be used
 *                        instead of the type_id to retrieve all tables with
 *                        the given label.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_tables_by_type = function(type_id, label, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_tables_by_type(type_id, label, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        type_id: type_id,
        label: label,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/tables/bytype", actual_request, callback);
};

/**
 * Retrieves information regarding the specified triggers or all existing
 * triggers currently active.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_triggers_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_triggers_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        trigger_ids: request.trigger_ids,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/triggers", actual_request, callback);
};

/**
 * Retrieves information regarding the specified triggers or all existing
 * triggers currently active.
 *
 * @param {String[]} trigger_ids  List of IDs of the triggers whose information
 *                                is to be retrieved. An empty list means
 *                                information will be retrieved on all active
 *                                triggers.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_triggers = function(trigger_ids, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_triggers(trigger_ids, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        trigger_ids: trigger_ids,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/triggers", actual_request, callback);
};

/**
 * Retrieves information for the specified data type. Given a type ID, the
 * database returns the data type schema, the label, and the semantic type
 * along with the type ID. If the user provides any combination of label and
 * semantic type, then the database returns the pertinent information for all
 * data types that match the input criteria.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_types_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_types_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        type_id: request.type_id,
        label: request.label,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/types", actual_request, callback);
};

/**
 * Retrieves information for the specified data type. Given a type ID, the
 * database returns the data type schema, the label, and the semantic type
 * along with the type ID. If the user provides any combination of label and
 * semantic type, then the database returns the pertinent information for all
 * data types that match the input criteria.
 *
 * @param {String} type_id  Type Id returned in response to a call to
 *                          {@linkcode GPUdb#create_type}.
 * @param {String} label  Option string that was supplied by user in a call to
 *                        {@linkcode GPUdb#create_type}.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_types = function(type_id, label, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_types(type_id, label, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        type_id: type_id,
        label: label,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/types", actual_request, callback);
};

/**
 * Runs multiple predicate-based updates in a single call.  With the list of
 * given expressions, any matching record's column values will be updated as
 * provided in <code>new_values_maps</code>.  There is also an optional
 * 'upsert' capability where if a particular predicate doesn't match any
 * existing record, then a new record can be inserted.
 * <p>
 * Note that this operation can only be run on an original table and not on a
 * collection or a result view.
 * <p>
 * This operation can update primary key values.  By default only 'pure primary
 * key' predicates are allowed when updating primary key values. If the primary
 * key for a table is the column 'attr1', then the operation will only accept
 * predicates of the form: "attr1 == 'foo'" if the attr1 column is being
 * updated.  For a composite primary key (e.g. columns 'attr1' and 'attr2')
 * then this operation will only accept predicates of the form: "(attr1 ==
 * 'foo') and (attr2 == 'bar')".  Meaning, all primary key columns must appear
 * in an equality predicate in the expressions.  Furthermore each 'pure primary
 * key' predicate must be unique within a given request.  These restrictions
 * can be removed by utilizing some available options through
 * <code>options</code>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.update_records_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.update_records_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        expressions: request.expressions,
        new_values_maps: request.new_values_maps,
        records_to_insert: (request.records_to_insert !== undefined && request.records_to_insert !== null) ? request.records_to_insert : [],
        records_to_insert_str: (request.data !== undefined && request.data !== null) ? GPUdb.encode(request.data) : [],
        record_encoding: (request.record_encoding !== undefined && request.record_encoding !== null) ? request.record_encoding : "json",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/update/records", actual_request, callback);
};

/**
 * Runs multiple predicate-based updates in a single call.  With the list of
 * given expressions, any matching record's column values will be updated as
 * provided in <code>new_values_maps</code>.  There is also an optional
 * 'upsert' capability where if a particular predicate doesn't match any
 * existing record, then a new record can be inserted.
 * <p>
 * Note that this operation can only be run on an original table and not on a
 * collection or a result view.
 * <p>
 * This operation can update primary key values.  By default only 'pure primary
 * key' predicates are allowed when updating primary key values. If the primary
 * key for a table is the column 'attr1', then the operation will only accept
 * predicates of the form: "attr1 == 'foo'" if the attr1 column is being
 * updated.  For a composite primary key (e.g. columns 'attr1' and 'attr2')
 * then this operation will only accept predicates of the form: "(attr1 ==
 * 'foo') and (attr2 == 'bar')".  Meaning, all primary key columns must appear
 * in an equality predicate in the expressions.  Furthermore each 'pure primary
 * key' predicate must be unique within a given request.  These restrictions
 * can be removed by utilizing some available options through
 * <code>options</code>.
 *
 * @param {String} table_name  Table to be updated. Must be a currently
 *                             existing table and not a collection or view.
 * @param {String[]} expressions  A list of the actual predicates, one for each
 *                                update; format should follow the guidelines
 *                                [here]{@linkcode GPUdb#filter}.
 * @param {Object[]} new_values_maps  List of new values for the matching
 *                                    records.  Each element is a map with
 *                                    (key, value) pairs where the keys are the
 *                                    names of the columns whose values are to
 *                                    be updated; the values are the new
 *                                    values.  The number of elements in the
 *                                    list should match the length of
 *                                    <code>expressions</code>.
 * @param {Object[]} data  An optional list of new json-avro encoded objects to
 *                         insert, one for each update, to be added to the set
 *                         if the particular update did not affect any objects.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> global_expression: An optional global
 *                          expression to reduce the search space of the
 *                          predicates listed in <code>expressions</code>.
 *                                  <li> bypass_safety_checks: When set to
 *                          'true', all predicates are available for primary
 *                          key updates.  Keep in mind that it is possible to
 *                          destroy data in this case, since a single predicate
 *                          may match multiple objects (potentially all of
 *                          records of a table), and then updating all of those
 *                          records to have the same primary key will, due to
 *                          the primary key uniqueness constraints, effectively
 *                          delete all but one of those updated records.
 *                          Values: true, false.
 *                                  <li> update_on_existing_pk: Can be used to
 *                          customize behavior when the updated primary key
 *                          value already exists, as described in
 *                          {@linkcode GPUdb#insert_records}. Values: true,
 *                          false.
 *                                  <li> record_id: ID of a single record to be
 *                          updated (returned in the call to
 *                          {@linkcode GPUdb#insert_records} or
 *                          {@linkcode GPUdb#get_records_from_collection}).
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.update_records = function(table_name, expressions, new_values_maps, data, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.update_records(table_name, expressions, new_values_maps, data, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        expressions: expressions,
        new_values_maps: new_values_maps,
        records_to_insert: [],
        records_to_insert_str: GPUdb.encode(data),
        record_encoding: "json",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/update/records", actual_request, callback);
};

/**
 * Updates the view specified by <code>table_name</code> to include full series
 * (track) information from the <code>world_table_name</code> for the series
 * (tracks) present in the <code>view_name</code>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.update_records_by_series_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.update_records_by_series_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        world_table_name: request.world_table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        reserved: (request.reserved !== undefined && request.reserved !== null) ? request.reserved : [],
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/update/records/byseries", actual_request, callback);
};

/**
 * Updates the view specified by <code>table_name</code> to include full series
 * (track) information from the <code>world_table_name</code> for the series
 * (tracks) present in the <code>view_name</code>.
 *
 * @param {String} table_name  Name of the view on which the update operation
 *                             will be performed. Must be an existing view.
 * @param {String} world_table_name  Name of the table containing the complete
 *                                   series (track) information.
 * @param {String} view_name  Optional name of the view containing the series
 *                            (tracks) which have to be updated.
 * @param {String[]} reserved
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.update_records_by_series = function(table_name, world_table_name, view_name, reserved, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.update_records_by_series(table_name, world_table_name, view_name, reserved, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        world_table_name: world_table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        reserved: (reserved !== undefined && reserved !== null) ? reserved : [],
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/update/records/byseries", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.visualize_image_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_image_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: request.table_names,
        world_table_names: request.world_table_names,
        x_column_name: request.x_column_name,
        y_column_name: request.y_column_name,
        track_ids: request.track_ids,
        min_x: request.min_x,
        max_x: request.max_x,
        min_y: request.min_y,
        max_y: request.max_y,
        width: request.width,
        height: request.height,
        projection: (request.projection !== undefined && request.projection !== null) ? request.projection : "PLATE_CARREE",
        bg_color: request.bg_color,
        style_options: request.style_options,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/visualize/image", actual_request, callback);
};

/**
 *
 * @param {String[]} table_names
 * @param {String[]} world_table_names
 * @param {String} x_column_name
 * @param {String} y_column_name
 * @param {String[][]} track_ids
 * @param {Number} min_x
 * @param {Number} max_x
 * @param {Number} min_y
 * @param {Number} max_y
 * @param {Number} width
 * @param {Number} height
 * @param {String} projection  Values: EPSG:4326, PLATE_CARREE, 900913,
 *                             EPSG:900913, 102100, EPSG:102100, 3857,
 *                             EPSG:3857, WEB_MERCATOR.
 * @param {Number} bg_color
 * @param {Object} style_options
 *                                <ul>
 *                                        <li> do_points:
 *                                        <li> do_shapes:
 *                                        <li> do_tracks:
 *                                        <li> do_symbology:
 *                                        <li> pointcolors:
 *                                        <li> pointsizes:
 *                                        <li> pointshapes:
 *                                        <li> shapelinewidths:
 *                                        <li> shapelinecolors:
 *                                        <li> shapefillcolors:
 *                                        <li> tracklinewidths:
 *                                        <li> tracklinecolors:
 *                                        <li> trackmarkersizes:
 *                                        <li> trackmarkercolors:
 *                                        <li> trackmarkershapes:
 *                                        <li> trackheadcolors:
 *                                        <li> trackheadsizes:
 *                                        <li> trackheadshapes:
 *                                </ul>
 * @param {Object} options
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.visualize_image = function(table_names, world_table_names, x_column_name, y_column_name, track_ids, min_x, max_x, min_y, max_y, width, height, projection, bg_color, style_options, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_image(table_names, world_table_names, x_column_name, y_column_name, track_ids, min_x, max_x, min_y, max_y, width, height, projection, bg_color, style_options, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: table_names,
        world_table_names: world_table_names,
        x_column_name: x_column_name,
        y_column_name: y_column_name,
        track_ids: track_ids,
        min_x: min_x,
        max_x: max_x,
        min_y: min_y,
        max_y: max_y,
        width: width,
        height: height,
        projection: (projection !== undefined && projection !== null) ? projection : "PLATE_CARREE",
        bg_color: bg_color,
        style_options: style_options,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/visualize/image", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.visualize_image_classbreak_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_image_classbreak_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: request.table_names,
        world_table_names: request.world_table_names,
        x_column_name: request.x_column_name,
        y_column_name: request.y_column_name,
        track_ids: request.track_ids,
        cb_column_name1: request.cb_column_name1,
        cb_vals1: request.cb_vals1,
        cb_column_name2: request.cb_column_name2,
        cb_vals2: request.cb_vals2,
        min_x: request.min_x,
        max_x: request.max_x,
        min_y: request.min_y,
        max_y: request.max_y,
        width: request.width,
        height: request.height,
        projection: (request.projection !== undefined && request.projection !== null) ? request.projection : "PLATE_CARREE",
        bg_color: request.bg_color,
        style_options: request.style_options,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/visualize/image/classbreak", actual_request, callback);
};

/**
 *
 * @param {String[]} table_names
 * @param {String[]} world_table_names
 * @param {String} x_column_name
 * @param {String} y_column_name
 * @param {String[][]} track_ids
 * @param {String} cb_column_name1
 * @param {String[]} cb_vals1
 * @param {String[]} cb_column_name2
 * @param {String[][]} cb_vals2
 * @param {Number} min_x
 * @param {Number} max_x
 * @param {Number} min_y
 * @param {Number} max_y
 * @param {Number} width
 * @param {Number} height
 * @param {String} projection  Values: EPSG:4326, PLATE_CARREE, 900913,
 *                             EPSG:900913, 102100, EPSG:102100, 3857,
 *                             EPSG:3857, WEB_MERCATOR.
 * @param {Number} bg_color
 * @param {Object} style_options
 *                                <ul>
 *                                        <li> do_points:
 *                                        <li> do_shapes:
 *                                        <li> do_tracks:
 *                                        <li> do_symbology:
 *                                        <li> pointcolors:
 *                                        <li> pointsizes:
 *                                        <li> pointshapes:
 *                                        <li> shapelinewidths:
 *                                        <li> shapelinecolors:
 *                                        <li> shapefillcolors:
 *                                        <li> tracklinewidths:
 *                                        <li> tracklinecolors:
 *                                        <li> trackmarkersizes:
 *                                        <li> trackmarkercolors:
 *                                        <li> trackmarkershapes:
 *                                        <li> trackheadcolors:
 *                                        <li> trackheadsizes:
 *                                        <li> trackheadshapes:
 *                                </ul>
 * @param {Object} options
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.visualize_image_classbreak = function(table_names, world_table_names, x_column_name, y_column_name, track_ids, cb_column_name1, cb_vals1, cb_column_name2, cb_vals2, min_x, max_x, min_y, max_y, width, height, projection, bg_color, style_options, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_image_classbreak(table_names, world_table_names, x_column_name, y_column_name, track_ids, cb_column_name1, cb_vals1, cb_column_name2, cb_vals2, min_x, max_x, min_y, max_y, width, height, projection, bg_color, style_options, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: table_names,
        world_table_names: world_table_names,
        x_column_name: x_column_name,
        y_column_name: y_column_name,
        track_ids: track_ids,
        cb_column_name1: cb_column_name1,
        cb_vals1: cb_vals1,
        cb_column_name2: cb_column_name2,
        cb_vals2: cb_vals2,
        min_x: min_x,
        max_x: max_x,
        min_y: min_y,
        max_y: max_y,
        width: width,
        height: height,
        projection: (projection !== undefined && projection !== null) ? projection : "PLATE_CARREE",
        bg_color: bg_color,
        style_options: style_options,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/visualize/image/classbreak", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.visualize_image_heatmap_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_image_heatmap_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: request.table_names,
        x_column_name: request.x_column_name,
        y_column_name: request.y_column_name,
        value_column_name: request.value_column_name,
        min_x: request.min_x,
        max_x: request.max_x,
        min_y: request.min_y,
        max_y: request.max_y,
        width: request.width,
        height: request.height,
        projection: (request.projection !== undefined && request.projection !== null) ? request.projection : "PLATE_CARREE",
        style_options: request.style_options,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/visualize/image/heatmap", actual_request, callback);
};

/**
 *
 * @param {String[]} table_names
 * @param {String} x_column_name
 * @param {String} y_column_name
 * @param {String} value_column_name
 * @param {Number} min_x
 * @param {Number} max_x
 * @param {Number} min_y
 * @param {Number} max_y
 * @param {Number} width
 * @param {Number} height
 * @param {String} projection  Values: EPSG:4326, PLATE_CARREE, 900913,
 *                             EPSG:900913, 102100, EPSG:102100, 3857,
 *                             EPSG:3857, WEB_MERCATOR.
 * @param {Object} style_options
 *                                <ul>
 *                                        <li> colormap:
 *                                        <li> blur_radius:
 *                                        <li> bg_color:
 *                                        <li> gradient_start_color:
 *                                        <li> gradient_end_color:
 *                                </ul>
 * @param {Object} options
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.visualize_image_heatmap = function(table_names, x_column_name, y_column_name, value_column_name, min_x, max_x, min_y, max_y, width, height, projection, style_options, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_image_heatmap(table_names, x_column_name, y_column_name, value_column_name, min_x, max_x, min_y, max_y, width, height, projection, style_options, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: table_names,
        x_column_name: x_column_name,
        y_column_name: y_column_name,
        value_column_name: value_column_name,
        min_x: min_x,
        max_x: max_x,
        min_y: min_y,
        max_y: max_y,
        width: width,
        height: height,
        projection: (projection !== undefined && projection !== null) ? projection : "PLATE_CARREE",
        style_options: style_options,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/visualize/image/heatmap", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.visualize_image_labels_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_image_labels_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        x_column_name: request.x_column_name,
        y_column_name: request.y_column_name,
        x_offset: request.x_offset,
        y_offset: request.y_offset,
        text_string: request.text_string,
        font: request.font,
        text_color: request.text_color,
        text_angle: request.text_angle,
        text_scale: request.text_scale,
        draw_box: request.draw_box,
        draw_leader: request.draw_leader,
        line_width: request.line_width,
        line_color: request.line_color,
        fill_color: request.fill_color,
        leader_x_column_name: request.leader_x_column_name,
        leader_y_column_name: request.leader_y_column_name,
        min_x: request.min_x,
        max_x: request.max_x,
        min_y: request.min_y,
        max_y: request.max_y,
        width: request.width,
        height: request.height,
        projection: (request.projection !== undefined && request.projection !== null) ? request.projection : "PLATE_CARREE",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/visualize/image/labels", actual_request, callback);
};

/**
 *
 * @param {String} table_name
 * @param {String} x_column_name
 * @param {String} y_column_name
 * @param {String} x_offset
 * @param {String} y_offset
 * @param {String} text_string
 * @param {String} font
 * @param {String} text_color
 * @param {String} text_angle
 * @param {String} text_scale
 * @param {String} draw_box
 * @param {String} draw_leader
 * @param {String} line_width
 * @param {String} line_color
 * @param {String} fill_color
 * @param {String} leader_x_column_name
 * @param {String} leader_y_column_name
 * @param {Number} min_x
 * @param {Number} max_x
 * @param {Number} min_y
 * @param {Number} max_y
 * @param {Number} width
 * @param {Number} height
 * @param {String} projection  Values: EPSG:4326, PLATE_CARREE, 900913,
 *                             EPSG:900913, 102100, EPSG:102100, 3857,
 *                             EPSG:3857, WEB_MERCATOR.
 * @param {Object} options
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.visualize_image_labels = function(table_name, x_column_name, y_column_name, x_offset, y_offset, text_string, font, text_color, text_angle, text_scale, draw_box, draw_leader, line_width, line_color, fill_color, leader_x_column_name, leader_y_column_name, min_x, max_x, min_y, max_y, width, height, projection, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_image_labels(table_name, x_column_name, y_column_name, x_offset, y_offset, text_string, font, text_color, text_angle, text_scale, draw_box, draw_leader, line_width, line_color, fill_color, leader_x_column_name, leader_y_column_name, min_x, max_x, min_y, max_y, width, height, projection, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        x_column_name: x_column_name,
        y_column_name: y_column_name,
        x_offset: x_offset,
        y_offset: y_offset,
        text_string: text_string,
        font: font,
        text_color: text_color,
        text_angle: text_angle,
        text_scale: text_scale,
        draw_box: draw_box,
        draw_leader: draw_leader,
        line_width: line_width,
        line_color: line_color,
        fill_color: fill_color,
        leader_x_column_name: leader_x_column_name,
        leader_y_column_name: leader_y_column_name,
        min_x: min_x,
        max_x: max_x,
        min_y: min_y,
        max_y: max_y,
        width: width,
        height: height,
        projection: (projection !== undefined && projection !== null) ? projection : "PLATE_CARREE",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/visualize/image/labels", actual_request, callback);
};

/**
 * Creates raster images of data in the given table based on provided input
 * parameters. Numerous parameters are required to call this function. Some of
 * the important parameters are the attributes of the generated images
 * (<code>bg_color</code>, <code>width</code>, <code>height</code>), the
 * collection of table names on which this function is to be applied, for which
 * shapes (point, polygon, tracks) the images are to be created and a user
 * specified session key. This session key is later used to fetch the generated
 * images. The operation is synchronous, meaning that a response will not be
 * returned until the images for all the frames of the video are fully
 * available.
 * <p>
 * Once the request has been processed then the generated video frames are
 * available for download via WMS using STYLES=cached. In this request the
 * LAYERS parameter should be populated with the session key passed in
 * <code>session_key</code> of the visualize video request and the FRAME
 * parameter indicates which 0-based frame of the video should be returned. All
 * other WMS parameters are ignored for this mode.
 * <p>
 * For instance, if a 20 frame video with the session key 'MY-SESSION-KEY' was
 * generated, the first frame could be retrieved with the URL:
 * <p>
 *     <a href="../rest/wms_rest.html"
 * target="_top">http://<hostname/ipAddress>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-SESSION-KEY&FRAME=0</a>
 * <p>
 * and the last frame could be retrieved with:
 * <p>
 *     <a href="../rest/wms_rest.html"
 * target="_top">http://<hostname/ipAddress>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-SESSION-KEY&FRAME=19</a>
 * <p>
 * The response payload provides, among other things, the number of frames
 * which were created.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.visualize_video_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_video_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: request.table_names,
        world_table_names: request.world_table_names,
        track_ids: request.track_ids,
        x_column_name: request.x_column_name,
        y_column_name: request.y_column_name,
        min_x: request.min_x,
        max_x: request.max_x,
        min_y: request.min_y,
        max_y: request.max_y,
        width: request.width,
        height: request.height,
        projection: (request.projection !== undefined && request.projection !== null) ? request.projection : "PLATE_CARREE",
        bg_color: request.bg_color,
        time_intervals: request.time_intervals,
        video_style: request.video_style,
        session_key: request.session_key,
        style_options: request.style_options,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/visualize/video", actual_request, callback);
};

/**
 * Creates raster images of data in the given table based on provided input
 * parameters. Numerous parameters are required to call this function. Some of
 * the important parameters are the attributes of the generated images
 * (<code>bg_color</code>, <code>width</code>, <code>height</code>), the
 * collection of table names on which this function is to be applied, for which
 * shapes (point, polygon, tracks) the images are to be created and a user
 * specified session key. This session key is later used to fetch the generated
 * images. The operation is synchronous, meaning that a response will not be
 * returned until the images for all the frames of the video are fully
 * available.
 * <p>
 * Once the request has been processed then the generated video frames are
 * available for download via WMS using STYLES=cached. In this request the
 * LAYERS parameter should be populated with the session key passed in
 * <code>session_key</code> of the visualize video request and the FRAME
 * parameter indicates which 0-based frame of the video should be returned. All
 * other WMS parameters are ignored for this mode.
 * <p>
 * For instance, if a 20 frame video with the session key 'MY-SESSION-KEY' was
 * generated, the first frame could be retrieved with the URL:
 * <p>
 *     <a href="../rest/wms_rest.html"
 * target="_top">http://<hostname/ipAddress>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-SESSION-KEY&FRAME=0</a>
 * <p>
 * and the last frame could be retrieved with:
 * <p>
 *     <a href="../rest/wms_rest.html"
 * target="_top">http://<hostname/ipAddress>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-SESSION-KEY&FRAME=19</a>
 * <p>
 * The response payload provides, among other things, the number of frames
 * which were created.
 *
 * @param {String[]} table_names  Names of the tables containing the data for
 *                                various layers of the resulting video.
 * @param {String[]} world_table_names  Optional name of the tables containing
 *                                      the data for the entire track when the
 *                                      <code>table_names</code> contains only
 *                                      part of the track data, but the entire
 *                                      track has to be rendered. The number of
 *                                      tables should match the number of
 *                                      tables in the <code>table_names</code>
 * @param {String[][]} track_ids  Tracks from the <code>table_names</code> to
 *                                be rendered.
 * @param {String} x_column_name  Name of the column containing the x
 *                                coordinates.
 * @param {String} y_column_name  Name of the column containing the y
 *                                coordinates.
 * @param {Number} min_x  Lower bound for the x values.
 * @param {Number} max_x  Upper bound for the x values.
 * @param {Number} min_y  Lower bound for the y values.
 * @param {Number} max_y  Upper bound for the y values.
 * @param {Number} width  Width of the generated image.
 * @param {Number} height  Height of the generated image.
 * @param {String} projection  Spatial Reference System (i.e. EPSG Code).
 *                             Values: EPSG:4326, PLATE_CARREE, 900913,
 *                             EPSG:900913, 102100, EPSG:102100, 3857,
 *                             EPSG:3857, WEB_MERCATOR.
 * @param {Number} bg_color  Background color of the generated image.
 * @param {Number[][]} time_intervals
 * @param {String} video_style
 * @param {String} session_key  User Provided session key that is later used to
 *                              retrieve the generated video from the WMS.
 * @param {Object} style_options  Styling options for the image.
 *                                <ul>
 *                                        <li> do_points: Rasterize point data
 *                                toggle.
 *                                        <li> do_shapes: Rasterize shapes
 *                                toggle.
 *                                        <li> do_tracks: Rasterize tracks
 *                                toggle.
 *                                        <li> pointcolors: RGB color value in
 *                                hex for the points.
 *                                        <li> pointsizes: Size of points.
 *                                        <li> pointshapes: Shape of the point.
 *                                        <li> shapelinewidths: Width of the
 *                                lines.
 *                                        <li> shapelinecolors: RGB color
 *                                values in hex for the line.
 *                                        <li> shapefillcolors: RGB color
 *                                values in hex for the fill color of the
 *                                shapes. Use '-1' for no fill.
 *                                        <li> tracklinewidths: Width of the
 *                                track lines. '0' implies do not draw track
 *                                lines.
 *                                        <li> tracklinecolors: RGB color
 *                                values for the track lines.
 *                                        <li> trackmarkersizes: Size of the
 *                                track point markers.
 *                                        <li> trackmarkercolors: Color of the
 *                                track point markers.
 *                                        <li> trackmarkershapes: Shape of
 *                                track point markers.
 *                                        <li> trackheadcolors: Color of track
 *                                head markers.
 *                                        <li> trackheadsizes: Size of track
 *                                head markers.
 *                                        <li> trackheadshapes: Shape of track
 *                                head markers.
 *                                </ul>
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.visualize_video = function(table_names, world_table_names, track_ids, x_column_name, y_column_name, min_x, max_x, min_y, max_y, width, height, projection, bg_color, time_intervals, video_style, session_key, style_options, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_video(table_names, world_table_names, track_ids, x_column_name, y_column_name, min_x, max_x, min_y, max_y, width, height, projection, bg_color, time_intervals, video_style, session_key, style_options, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: table_names,
        world_table_names: world_table_names,
        track_ids: track_ids,
        x_column_name: x_column_name,
        y_column_name: y_column_name,
        min_x: min_x,
        max_x: max_x,
        min_y: min_y,
        max_y: max_y,
        width: width,
        height: height,
        projection: (projection !== undefined && projection !== null) ? projection : "PLATE_CARREE",
        bg_color: bg_color,
        time_intervals: time_intervals,
        video_style: video_style,
        session_key: session_key,
        style_options: style_options,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/visualize/video", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.visualize_video_heatmap_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_video_heatmap_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: request.table_names,
        x_column_name: request.x_column_name,
        y_column_name: request.y_column_name,
        min_x: request.min_x,
        max_x: request.max_x,
        min_y: request.min_y,
        max_y: request.max_y,
        time_intervals: request.time_intervals,
        width: request.width,
        height: request.height,
        projection: (request.projection !== undefined && request.projection !== null) ? request.projection : "PLATE_CARREE",
        video_style: request.video_style,
        session_key: request.session_key,
        style_options: request.style_options,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/visualize/video/heatmap", actual_request, callback);
};

/**
 *
 * @param {String[]} table_names
 * @param {String} x_column_name
 * @param {String} y_column_name
 * @param {Number} min_x
 * @param {Number} max_x
 * @param {Number} min_y
 * @param {Number} max_y
 * @param {Number[][]} time_intervals
 * @param {Number} width
 * @param {Number} height
 * @param {String} projection  Values: EPSG:4326, PLATE_CARREE, 900913,
 *                             EPSG:900913, 102100, EPSG:102100, 3857,
 *                             EPSG:3857, WEB_MERCATOR.
 * @param {String} video_style
 * @param {String} session_key
 * @param {Object} style_options
 *                                <ul>
 *                                        <li> colormap:
 *                                        <li> blur_radius:
 *                                        <li> bg_color:
 *                                        <li> gradient_start_color:
 *                                        <li> gradient_end_color:
 *                                </ul>
 * @param {Object} options
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.visualize_video_heatmap = function(table_names, x_column_name, y_column_name, min_x, max_x, min_y, max_y, time_intervals, width, height, projection, video_style, session_key, style_options, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_video_heatmap(table_names, x_column_name, y_column_name, min_x, max_x, min_y, max_y, time_intervals, width, height, projection, video_style, session_key, style_options, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: table_names,
        x_column_name: x_column_name,
        y_column_name: y_column_name,
        min_x: min_x,
        max_x: max_x,
        min_y: min_y,
        max_y: max_y,
        time_intervals: time_intervals,
        width: width,
        height: height,
        projection: (projection !== undefined && projection !== null) ? projection : "PLATE_CARREE",
        video_style: video_style,
        session_key: session_key,
        style_options: style_options,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/visualize/video/heatmap", actual_request, callback);
};
